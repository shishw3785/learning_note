python简介
	连google都在大规模使用,不用担心学了没用
	当用一种语言开始软件开发时,除了编写代码外,还需要很多基本已经这好的东西加速开发,如开发一个邮件客户端,如果从最底层开始编写网络协议相关的代码可能要一年多也不行.高级语言通常会提供一个比较完善的基础代码库,可以直接调用.如由件协议的SMTP库,我们就可以在现有代码库上开发,短时间就能写邮件客户端软件出来

	python提供了非常完善的基础代码库,包括网络,文件,GUI,数据库等和第三方库,可以直接使用

	优点
		简洁,高效
	缺点
		运行速度慢,因为是解释型语言,代码在执行时会一行一行地翻译成CPU能理解的机器码

python解释器
	当编写python代码时,得到的是一个.py扩展名的文本文件,要运行代码,就需要python解释器去执行

	官网安装Python后就得到了一个官方解释器材cpython(使用最广),用c语言开发,在命令行下python就启动cpython了

输入和输出
	>>> print('hello, world')
	hello, world

	>>> print('hello', 'world')
	hello world    #print接受多个字符,用逗号隔开,打印时每遇一个, 就会输出一个空格

	print()也可以打印整数，或者计算结果：

	>>> print(300)
	300
	>>> print(100 + 200)
	300

	>>> print('100 + 200 =', 100 + 200)
	100 + 200 = 300

	输入
	>>> name = input()
	Michael
	>>> name
	'Michael'

	>>> name = input('please enter your name: ') #显示字符串提醒
	please enter your name: leison
	>>> print('hello', name)
	hello leison

python基础
	任何一种语言都有一套语法,编译器或解释器就是把符合语法的代码转译给CPU能识别的机器码

	# 开头是注释
	每一行都是一个语句,语句以冒号 : 结尾时,缩进的语句称为代码块,应以4个空格缩进,好处是让长语句缩短成短语句,缺点是复制后的代码要重新检验缩进标准

	数据类型,Python能直接处理的数据类型
		整数
			可以处理任意大意的整数,包括负整数
				1 100 -8 0
			十六进制
				十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

		浮点数
			1.23，3.14，-9.01
			很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等

			整数和浮点数在计算机内部存储方式不同,整数是精确的,而浮点数有时要四舍五入

		字符串
			以'' 或 "" 括起来的任意文本
				'abc'
				"Im' ok" # 单引号本身也是字符,用双引号括起来,里面的空格也是字符
				空字符串 ' ' #注意空格

			转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：

			>>> print('I\'m ok.')
			I'm ok.
			>>> print('I\'m learning\nPython.')
			I'm learning
			Python.
			>>> print('\\\n\\')
			\
			\
			如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：

			>>> print('\\\t\\')
			\       \
			>>> print(r'\\\t\\')
			\\\t\\

			如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：

			>>> print('''line1
			... line2
			... line3''')
			line1
			line2
			line3

		布尔值
			只有True和False,要么是True要么是False

			>>> True
			True
			>>> False
			False
			>>> 3 > 2
			True
			>>> 3 > 5
			False

			布尔值可以用and、or和not运算。

			and运算是与运算，只有所有都为True，and运算结果才是True：

			>>> True and True
			True
			>>> True and False
			False
			>>> False and False
			False
			>>> 5 > 3 and 3 > 1
			True
			or运算是或运算，只要其中有一个为True，or运算结果就是True：

			>>> True or True
			True
			>>> True or False
			True
			>>> False or False
			False
			>>> 5 > 3 or 1 > 3
			True

			not运算是非运算，它是一个单目运算符，把True变成False，False变成True：

			>>> not True
			False
			>>> not False
			True
			>>> not 1 > 2
			True

		空值
			特殊值,用None表示,不能理解为0,因为0有意义

		变量
			等号 = 是赋值语句,可以把任意数据类型赋值给变量
			变量名必须是英文数字与_的组合,不能是数字开头

			a = 1
			变量a是一个整数。

			原理,在内容中创建数据1,在内存中创建变量且名a并把它指向数据1

			t_007 = 'T007'
			变量t_007是一个字符串。

			Answer = True
			变量Answer是一个布尔值True。

		python是动态语言
			a = 1
			a = 'abc'
			变量可以赋值任何类型(不固定),所以是动态固语言,灵活,JAVA是静态语言变量要先定义数据类型如int a = 1

		赋值 = 
			x = 10
			x = x + 2  --> x =12
			=不是数学常识的=号,而是赋值的意思

		常量
			通常用大写表示
			如 PI = 3.1415926

		/ 除法
			/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

			>>> 9 / 3
			3.0
			还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

			>>> 10 // 3
			3
		 % 求余
		 	>>> 10 % 3
			1

字符串和编码
	
	编码
	Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
	Unicode编码转化为“可变长编码”的UTF-8编码

	在内存中,统一用Unicode编码,当需要保存到硬盘或传输时(浏览器转输内容)就换UTF-8编码

	python字符串
		在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：

		>>> print('包含中文的str')
		包含中文的str
		对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

		>>> ord('A')
		65
		>>> ord('中')
		20013
		>>> chr(66)
		'B'
		>>> chr(25991)
		'文'

		如果知道字符的整数编码，还可以用十六进制这么写str：

		>>> '\u4e2d\u6587'
		'中文'

		由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

		Python对bytes类型的数据用带b前缀的单引号或双引号表示：

		x = b'ABC'
		要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。(节省了空间)

		以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

		>>> 'ABC'.encode('ascii')
		b'ABC'
		>>> '中文'.encode('utf-8')
		b'\xe4\xb8\xad\xe6\x96\x87'
		>>> '中文'.encode('ascii')
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
		纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

		反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

		>>> b'ABC'.decode('ascii')
		'ABC'
		>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
		'中文'
		如果bytes中包含无法解码的字节，decode()方法会报错：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
		Traceback (most recent call last):
		  ...
		UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
		如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
		'中'

		要计算str包含多少个字符，可以用len()函数：

		>>> len('ABC')
		3
		>>> len('中文')
		2
		len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

		>>> len(b'ABC')
		3
		>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
		6
		>>> len('中文'.encode('utf-8'))  #encode转成bytes类型
		6
		可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

		python保存的文本如果包含中文要在文件头添加
		#!/usr/bin/env python3  #linux 设置
		# -*- coding: utf-8 -*-   #编码设置
		并且文本编译软件设置选择UTF-8 without BOM编码



		格式化输出
		>>> 'Hello, %s' % 'world'
		'Hello, world'
		>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
		'Hi, Michael, you have $1000000.'
		你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

		补位
		>>> print('%2d-%02d' % (3,1))
		3-01
		>>> print('%.2f' % 3.1415)
		3.14

		需要 %字符,可以通过%转义
		>>> 'growth rate: %d %%' % 7
		'growth rate: 7 %'

		format()也可以格式化输出


list和tuple 
	列表是同置的一种内置的数据类型,有序的集合,可以随时添加和删除其中的元素

	>>> classmates = ['Michael', 'Bob', 'Tracy']
	>>> classmates
	['Michael', 'Bob', 'Tracy']

	可以用len()函数计算里面的个数
	>>> len(classmates)
	3

	用索引来访问里面元素,从0开始
	>>> classmates[0]
	'Michael'
	>>> classmates[1]
	'Bob'
	>>> classmates[2]
	'Tracy'
	>>> classmates[3]
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	IndexError: list index out of range

	取最后一个元素
	classmates[-1]
	>>>'Tracy'
	以此类推可以获取倒数的元素-2,-3

	List是可变的元素,可以追加素到末尾
	classmates.append('Adm')
	>>> classmates
	['Michael', 'Bob', 'Tracy', 'Adam']

	也可以把元素插入指定位置,比如索引1的位置
	classmates.insert(1,'Jack')
	['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']

	删除List末尾元素
	classmates.pop()
	'Adam'
	>>> classmates
	['Michael', 'Jack', 'Bob', 'Tracy']

	删除指定位置元素,pop(i)
	classmates.pop(1)
	['Michael', 'Bob', 'Tracy']

	元素替换
	classmates[1] = 'Sarah'
	['Michael', 'Sarah', 'Tracy']

	list元素的数据类型也可以不同
	L = ['Apple', 123, True ]

	list元素也可以是另一个List
	s = ['python', 'java', ['asp', 'php'], 'sql']

	p = ['asp', 'php']
	s = ['python', 'java', p, 'sql']  #元素也可以是变量

	len(s)
	4

	s[2][1] 或p[1]
	>>> 'php'

	空list
	L = []
	len(L)
	>>> 0 

	tuple元组
		有序不可变,一旦初始化就不能修改

		classmates = ('Michael', 'Bob', 'Tracy')
		可以通过 classmates[i] 索引读取数据

		但是不能变了,没有append(),insert(),也不能重新赋值classmates[1] = 'hello'

		空的tuple，可以写成()：

			>>> t = ()
			>>> t
			()

		"可变的元组"
		>>> t = ('a', 'b', ['A', 'B'])
		>>> t[2][0] = 'X'
		>>> t[2][1] = 'Y'
		>>> t
		('a', 'b', ['X', 'Y'])
		#不可变指的是元素的指向不可变,但元素本身是List它是可变的

条件判断
	if语句

		if <条件判断1>:
		    <执行1>
		elif <条件判断2>:
		    <执行2>
		elif <条件判断3>:
		    <执行3>
		else:
		    <执行4>

	例
	age = 16
	if age > 18:
	    print('adult', 'you age is', age)
	elif age < 18:
	    print('baby', 'you age is', age)
	else:
	    print('i dont know')

	 简写
	 	if x:
		    print('True')
		只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。

	结合input()
		s = input('birth: ')
		birth = int(s)   #利用int()把str转成整数类型
		if birth < 2000:
		    print('00前')
		else:
		    print('00后')


循环
	for循环

	for x in ...循环就是把每个元素(可以是列表或元组的元素)代入变量x，然后执行缩进块的语句。

		例
		sum = 0
		for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
		    sum = sum + x
		print(sum)

		range()函数可以生成整数序列,利用list()函数可以让其转成列表
		>>> list(range(5))    #从0开始小于5的整数
		[0, 1, 2, 3, 4]


	while循环
		while循环，只要条件满足，就不断循环，条件不满足时退出循环

		例
		sum = 0
		n = 99
		while n > 0:
		    sum = sum + n
		    n = n - 2
		print(sum)

	break语句
		提前结束循环

		n = 1
		while n <= 100:
		    if n > 10: # 当n = 11时，条件满足，执行break语句
		        break # break语句会结束当前循环
		    print(n)
		    n = n + 1
		print('END')

	continue
		通过continue语句，跳过当前的这次循环，直接开始下一次循环。

		n = 0
		while n < 10:
		    n = n + 1
		    if n % 2 == 0: # 如果n是偶数，执行continue语句
		        continue   #语句会直接继续下一轮循环，后续的print()语句不会执行
		    print(n)


字典dic 与 set

	字典
		>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}  #创建字典
		>>> d['Michael']
		95

		#key-value存储方式 查询速度快

		把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

		>>> d['Adam'] = 67   #额外添加键值
		>>> d['Adam']
		67
		由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

		>>> d['Jack'] = 90     
		>>> d['Jack']
		90
		>>> d['Jack'] = 88    #修改值
		>>> d['Jack']
		88

		要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：

		>>> 'Thomas' in d
		False
		二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：

		>>> d.get('Thomas')
		>>> d.get('Thomas', -1)
		-1
		注意：返回None的时候Python的交互环境不显示结果。

		要删除一个key，用pop(key)方法，对应的value也会从dict中删除：

		>>> d.pop('Bob')
		75
		>>> d
		{'Michael': 95, 'Tracy': 85}

		请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

		和list比较，dict有以下几个特点：

		查找和插入的速度极快，不会随着key的增加而变慢；
		需要占用大量的内存，内存浪费多。
		而list相反：

		查找和插入的时间随着元素的增加而增加；
		占用空间小，浪费内存很少。
		所以，dict是用空间来换取时间的一种方法

		dic 的key必须是不可变的对象,通过key计算出velue称做哈希算法
			字符串与整数是不可变的,可以做为key值
			list是可变的,不能做key值

	set
		set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

		要创建一个set，需要提供一个list作为输入集合：

		>>> s = set([1, 2, 3])
		>>> s
		{1, 2, 3}
		注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

		重复元素在set中自动被过滤：

		>>> s = set([1, 1, 2, 2, 3, 3])
		>>> s
		{1, 2, 3}
		通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		通过remove(key)方法可以删除元素：

		>>> s.remove(4)
		>>> s
		{1, 2, 3}
		set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

		>>> s1 = set([1, 2, 3])
		>>> s2 = set([2, 3, 4])
		>>> s1 & s2
		{2, 3}
		>>> s1 | s2
		{1, 2, 3, 4}
		set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象

		对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：

		>>> a = ['c', 'b', 'a']
		>>> a.sort()
		>>> a
		['a', 'b', 'c']
		而对于不可变对象，比如str，对str进行操作呢：

		>>> a = 'abc'
		>>> a.replace('a', 'A')
		'Abc'
		>>> a
		'abc'             #虽然有replace方法,但a的变量内容还是不变的


函数
	调用函数
		调用abs函数：

		求绝对值
		>>> abs(100)
		100
		>>> abs(-20)
		20

		max函数max()可以接收任意多个参数，并返回最大的那个：

		>>> max(1, 2)
		2
		>>> max(2, 3, 1, -5)
		3

		数据类型转换
		>>> int('123')
		123
		>>> int(12.34)
		12
		>>> float('12.34')
		12.34
		>>> str(1.23)
		'1.23'
		>>> str(100)
		'100'
		>>> bool(1)
		True
		>>> bool('')   #整数0也是False
		False

		函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

		>>> a = abs # 变量a指向abs函数
		>>> a(-1) # 所以也可以通过a调用abs函数
		1

		调用函数要传入正确的参数,否则会出错,可以看错误信息


	定义函数
		def my_abs(x):
		    if x >= 0:
		        return x
		    else:
		        return -x

		print(my_abs(-99))

		用def语句, 函数名my_abs, x参数 , : 冒号  缩进语中编写函数体, 用 return 返回函数值

		一旦遇到return 时,函数就执行完毕,并将结果返回, 如果没有return语句,函数执行完毕也会返回结果,只是结果为 None,  return None 可以简写为 return

		把my_abs()函数定义保存为abstest.py文件,那么可以在该文件的当前目录下启动python解释器, 用  from abstest import my_abs 来导入my_abs()函数,注意是 abstest不包含  .py

		空函数
			定义一个函数什么事也不想做

			def nop():
				pass

			pass语句什么都不做,作用,作为占位符,如还没想好怎么写代码,可以放pass,让代码先能运行起来, pass 也可以放在其他语句中

			if age >= 18:
				pass	

			修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：

				def my_abs(x):
				    if not isinstance(x, (int, float)):
				        raise TypeError('bad operand type')
				    if x >= 0:
				        return x
				    else:
				        return -x

		返回多个值
			import math

			def move(x, y, step, angle=0):
			    nx = x + step * math.cos(angle)
			    ny = y - step * math.sin(angle)
			    return nx, ny

			>>> x, y = move(100, 100, 60, math.pi / 6)
			>>> print(x, y)
			151.96152422706632 70.0
			但其实这只是一种假象，Python函数返回的仍然是单一值：

			>>> r = move(100, 100, 60, math.pi / 6)
			>>> print(r)
			(151.96152422706632, 70.0)
			其实返回的是一个元组


	函数的参数
		计算x4、x5…

		def power(x, n):
		    s = 1
		    while n > 0:
		        n = n - 1
		        s = s * x
		    return s

		默认参数
			def power(x, n=2):
			    s = 1
			    while n > 0:
			        n = n - 1
			        s = s * x
			    return s
			这样，当我们调用power(5)时，相当于调用power(5, 2)：

			>>> power(5)
			25
			>>> power(5, 2)
			25

			注意：

				一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

				二是如何设置默认参数。

				当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

				使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

			def enroll(name, gender, age=6, city='Beijing'):
			    print('name:', name)
			    print('gender:', gender)
			    print('age:', age)
			    print('city:', city)
			这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：

			>>> enroll('Sarah', 'F')
			name: Sarah
			gender: F
			age: 6
			city: Beijing

			只有与默认参数不符的学生才需要提供额外的信息：

			enroll('Bob', 'M', 7) # city没有取值,使用默认值
			enroll('Adam', 'M', city='Tianjin')  #不按顺序设值要指名参数名city

			定义默认参数要牢记一点：默认参数必须指向不变对象！

			def add_end(L=None):                   #在如果 L = [],每次add_end()后L都会添加END
			    if L is None:
			        L = []
			    L.append('END')
			    return L
			现在，无论调用多少次，都不会有问题：

			>>> add_end()
			['END']
			>>> add_end()
			['END']

		可变参数
			如若要算a*a + b*b + c*c....

			def calc(numbers):
			    sum = 0
			    for n in numbers:
			        sum = sum + n * n
			    return sum
			但是调用的时候，需要先组装出一个list或tuple：

			>>> calc([1, 2, 3])
			14
			>>> calc((1, 3, 5, 7))
			84

			我们把函数的参数改为可变参数：

			def calc(*numbers):            #在函数内部numbers接收到的是一个tuple,可传入任意个参数
			    sum = 0
			    for n in numbers:
			        sum = sum + n * n
			    return sum

			调用函数的方式可以简化成这样：

			>>> calc(1, 2, 3)
			14
			>>> calc(1, 3, 5, 7)
			84

			Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：

			>>> nums = [1, 2, 3]
			>>> calc(*nums)
			14

		关键字参数
			可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：

			def person(name, age, **kw):
			    print('name:', name, 'age:', age, 'other:', kw)
			函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：

			>>> person('Michael', 30)
			name: Michael age: 30 other: {}
			也可以传入任意个数的关键字参数：

			>>> person('Bob', 35, city='Beijing')
			name: Bob age: 35 other: {'city': 'Beijing'}
			>>> person('Adam', 45, gender='M', job='Engineer')
			name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

			和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

			>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
			>>> person('Jack', 24, city=extra['city'], job=extra['job'])
			name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

			当然，上面复杂的调用可以用简化的写法：

			>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
			>>> person('Jack', 24, **extra)
			name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}


		命名关键字参数
			如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：

			def person(name, age, *, city, job):   #如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：
			    print(name, age, city, job)

			和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

			调用方式如下：

			>>> person('Jack', 24, city='Beijing', job='Engineer')  
			Jack 24 Beijing Engineer
			#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

			>>> person('Jack', 24, 'Beijing', 'Engineer')
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: person() takes 2 positional arguments but 4 were given
			由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。

			如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：

			def person(name, age, *args, city, job):
			    print(name, age, args, city, job)

			命名关键字参数可以有缺省值，从而简化调用：

			def person(name, age, *, city='Beijing', job):
			    print(name, age, city, job)
			由于命名关键字参数city具有默认值，调用时，可不传入city参数：

			>>> person('Jack', 24, job='Engineer')
			Jack 24 Beijing Engineer

		参数组合
			在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。


	递归函数
		在函数内部可以调用其它函数,如果调用的是自己本身,那就是递归函数

		计算n的阶乘 n!=n * (n-1) * (n-2).... * 1
		def fact(n):
		    if n==1:
		        return 1
		    return n * fact(n - 1)

		递归函数优点是逻辑清晰,简单

		使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)

		解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

		尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

		上面的fact(n)函数由于return n * fact(n - 1）引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

		def fact(n):
		    return fact_iter(n, 1)

		def fact_iter(num, product):
		    if num == 1:
		        return product
		    return fact_iter(num - 1, num * product)

		fact(5)对应的fact_iter(5, 1)的调用如下：

		===> fact_iter(5, 1)
		===> fact_iter(4, 5)
		===> fact_iter(3, 20)
		===> fact_iter(2, 60)
		===> fact_iter(1, 120)
		===> 120               #return 120(product)


高级特性 切片
	
	>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
	>>> L[0:3]
	['Michael', 'Sarah', 'Tracy']

	L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。

	如果第一个索引是0，还可以省略：

	>>> L[:3]
	['Michael', 'Sarah', 'Tracy']
	也可以从索引1开始，取出2个元素出来：

	>>> L[1:3]
	['Sarah', 'Tracy']

	类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：

	>>> L[-2:]
	['Bob', 'Jack']
	>>> L[-2:-1]
	['Bob']

	切片操作十分有用。我们先创建一个0-99的数列：

	>>> L = list(range(100))
	>>> L
	[0, 1, 2, 3, ..., 99]
	可以通过切片轻松取出某一段数列。比如前10个数：

	>>> L[:10]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

	前10个数，每两个取一个：

	>>> L[:10:2]
	[0, 2, 4, 6, 8]
	所有数，每5个取一个：

	>>> L[::5]
	[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
	甚至什么都不写，只写[:]就可以原样复制一个list：

	>>> L[:]
	[0, 1, 2, 3, ..., 99]

	tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：

	>>> (0, 1, 2, 3, 4, 5)[:3]
	(0, 1, 2)
	字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：

	>>> 'ABCDEFG'[:3]
	'ABC'
	>>> 'ABCDEFG'[::2]
	'ACEG'

高级特性 迭代
	Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上

	只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
		>>> d = {'a': 1, 'b': 2, 'c': 3}
		>>> for key in d:
		...     print(key)
		...
		a
		c
		b

	因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

	默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()

	字符串也可以迭代

	判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：

		>>> from collections import Iterable
		>>> isinstance('abc', Iterable) # str是否可迭代
		True
		>>> isinstance([1,2,3], Iterable) # list是否可迭代
		True
		>>> isinstance(123, Iterable) # 整数是否可迭代
		False

	Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

		>>> for i, value in enumerate(['A', 'B', 'C']):
		...     print(i, value)
		...
		0 A
		1 B
		2 C


高级特性 列表生成式
	>>> [x * x for x in range(1, 11)]
	[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环

	for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

	>>> [x * x for x in range(1, 11) if x % 2 == 0]
	[4, 16, 36, 64, 100]

	for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：

	>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
	>>> for k, v in d.items():
	...     print(k, '=', v)
	...
	y = B
	x = A
	z = C

	因此，列表生成式也可以使用两个变量来生成list：

	>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
	>>> [k + '=' + v for k, v in d.items()]
	['y=B', 'x=A', 'z=C']

	最后把一个list中所有的字符串变成小写：

	>>> L = ['Hello', 'World', 'IBM', 'Apple']
	>>> [s.lower() for s in L]


	在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else

	>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
	[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]


高级特性 生成器

	按照某种算法,一边循环一边计算的机制,称为生成器(generator)
	
	要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

		>>> L = [x * x for x in range(10)]
		>>> L
		[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
		>>> g = (x * x for x in range(10))
		>>> g
		<generator object <genexpr> at 0x1022ef630>

	如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

		>>> next(g)
		0
		>>> next(g)
		1
		>>> next(g)
		4
		>>> next(g)
		9
		>>> next(g)
		16
		>>> next(g)
		25
		>>> next(g)
		36
		>>> next(g)
		49
		>>> next(g)
		64
		>>> next(g)
		81
		>>> next(g)
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		StopIteration
		我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。

	一般都是用for循环打印
		for i in g:
			print(i)

		for循环不用关心会抛出错误

	著名的斐波拉契数列 用函数表示
		def fib(max):
		    n, a, b = 0, 0, 1
		    while n < max:
		        print(b)
		        a, b = b, a + b
		        n = n + 1
		    return 'done'

		要把fib函数变成generator，只需要把print(b)改为yield b就可以了(因为这数据就是类似生成器)：

			def fib(max):
			    n, a, b = 0, 0, 1
			    while n < max:
			        yield b
			        a, b = b, a + b
			        n = n + 1
			    return 'done'

		这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：

		>>> f = fib(6)
		>>> f
		<generator object fib at 0x104feaaa0>

	函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

		举个简单的例子，定义一个generator，依次返回数字1，3，5：

			def odd():
			    print('step 1')
			    yield 1
			    print('step 2')
			    yield(3)
			    print('step 3')
			    yield(5)
		调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：

			>>> o = odd()
			>>> next(o)
			step 1
			1
			>>> next(o)
			step 2
			3
			>>> next(o)
			step 3
			5
			>>> next(o)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			StopIteration


	但一般是用for来返回
		>>> for n in fib(6):
		...     print(n)
		...
		1
		...

		如要取得return 的‘done'值,就要捕获错误,先略过

高级特性 迭代器
	这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

		可以使用isinstance()判断一个对象是否是Iterable对象：

		>>> from collections.abc import Iterable
		>>> isinstance([], Iterable)
		True
		>>> isinstance({}, Iterable)
		True
		>>> isinstance('abc', Iterable)
		True
		>>> isinstance((x for x in range(10)), Iterable)
		True
		>>> isinstance(100, Iterable)
		False

	可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

		可以使用isinstance()判断一个对象是否是Iterator对象：

		>>> from collections.abc import Iterator
		>>> isinstance((x for x in range(10)), Iterator)
		True
		>>> isinstance([], Iterator)
		False
		>>> isinstance({}, Iterator)
		False

	生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值

	把list、dict、str等Iterable变成Iterator可以使用iter()函数：

		>>> isinstance(iter([]), Iterator)
		True
		>>> isinstance(iter('abc'), Iterator)
		True


函数式编程
	函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。

	函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量

	函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

	Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。


	高阶函数

		变量可以指向函数

			>>> abs(-10)
			10
			但是，如果只写abs呢？

			>>> abs
			<built-in function abs>
			可见，abs(-10)是函数调用，而abs是函数本身。

			要获得函数调用结果，我们可以把结果赋值给变量：

			>>> x = abs(-10)
			>>> x
			10
			但是，如果把函数本身赋值给变量呢？

			>>> f = abs
			>>> f
			<built-in function abs>
			结论：函数本身也可以赋值给变量，即：变量可以指向函数。

			>>> f = abs
			>>> f(-10)
			10
			成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。

		函数名也是变量名

			>>> abs = 10
			>>> abs(-10)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: 'int' object is not callable
			把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！

		传入函数
			既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

			一个最简单的高阶函数：

			def add(x, y, f):
			    return f(x) + f(y)
			当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：

			x = -5
			y = 6
			f = abs
			f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
			return 11


	map() 与 reduce()
		map()
			该函数接接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回

			如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上,让其变成 [1, 4, 9, 16, 25, 36, 49, 64, 81]

			>>> def f(x):
			...     return x * x
			...
			>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
			>>> list(r)
			[1, 4, 9, 16, 25, 36, 49, 64, 81]

		reduce()
			reduce()接收两个参数,一个是函数(必须接收两个参数),另一个是序列(iterable),函数作用后的结果继续和序列的下一个元素作累积计算,然后把结果返回


			求和

				>> reduce(add, [1,2,3,4,5])  #add函数只接收两个参数  先是add(1,2)-->add(3,3)-->add(6,4)-->add(10,5)
				15



			如把str转成int
				
				from functools import reduce

				dic = {'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}

				s = '13579'

				def yes(s):
				    def f(x, y):
				        return x * 10 + y
				    def ooo(n):
				        return dic[n]
				    return reduce(f, map(ooo, s))

				print(yes(s))


	filter()
		Python内建的filter()函数用于过滤序列。

		和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

		例如，在一个list中，删掉偶数，只保留奇数，可以这么写：

		def is_odd(n):
		    return n % 2 == 1

		list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
		# 结果: [1, 5, 9, 15]

		其它先略过

	sorted()
		对list进行排序

		>>> sorted([36, 5, -12, 9, -21])
		[-21, -12, 5, 9, 36]

		sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：

		>>> sorted([36, 5, -12, 9, -21], key=abs)
		[5, 9, -12, -21, 36]

		给sorted传入key函数，即可实现忽略大小写的排序：

		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)  #比对第一个字母
		['about', 'bob', 'Credit', 'Zoo']
		要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：

		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
		['Zoo', 'Credit', 'bob', 'about']

		练习假设我们用一组tuple表示学生名字和成绩：

		L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
		请用sorted()对上述列表分别按名字排序：

			L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

			d = {}

			for x,y in L:   #换成字典对应
			    d[x] = y   

			def f(n):
			    t = []
			    s = []
			    for i in n:      #把要排序的值整合到t列表
			        t.append(i[0])
			    for x in sorted(t, key=str.lower): #按首写字母排序
			        tu = (x, d[x])
			        s.append(tu)
			    return s

			print(f(L))

		安分数来排

			L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

			d = {}

			for x,y in L:    #也是换成字典不过key字是分数
			    d[y] = x

			def f(n):
			    t = []
			    s = []
			    for i in n:
			        t.append(i[1])
			    for x in sorted(t, key=abs):
			        tu = (d[x],x)
			        s.append(tu)
			    return s

			print(f(L))

        
        
    返回函数
    	把函数作为结果值返回。

		我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：

		def calc_sum(*args):
		    ax = 0
		    for n in args:
		        ax = ax + n
		    return ax
		但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：

		def lazy_sum(*args):
		    def sum():
		        ax = 0
		        for n in args:
		            ax = ax + n
		        return ax
		    return sum
		当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

		>>> f = lazy_sum(1, 3, 5, 7, 9)
		>>> f
		<function lazy_sum.<locals>.sum at 0x101c6ed90>
		调用函数f时，才真正计算求和的结果：

		>>> f()
		25
		在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

		返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量

		def count():
		    fs = []
		    for i in range(1, 4):
		        def f():
		             return i*i
		        fs.append(f)
		    return fs

		f1, f2, f3 = count()
		在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。

		你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：

		>>> f1()
		9
		>>> f2()
		9
		>>> f3()
		9
		全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

		如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

		def count():
		    def f(j):
		        def g():
		            return j*j
		        return g
		    fs = []
		    for i in range(1, 4):
		        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
		    return fs

		练习利用闭包返回一个计数器函数，每次调用它返回递增整数

			def count():
			    n = 0
			    def f():
			        nonlocal n   #声明变成了全局变量,每次调用都是count里的n值
			        n = n + 1
			        return n
			    return f

			now_a = count()

			print(now_a(), now_a(), now_a())


	匿名函数
		当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
		>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
		[1, 4, 9, 16, 25, 36, 49, 64, 81]
		通过对比可以看出，匿名函数lambda x: x * x实际上就是：

		def f(x):
		    return x * x

		关键字lambda表示匿名函数，冒号前面的x表示函数参数。

		匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

		用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

		>>> f = lambda x: x * x
		>>> f
		<function <lambda> at 0x101c6ef28>
		>>> f(5)
		25


		同样，也可以把匿名函数作为返回值返回，比如：

		def build(x, y):
	    	return lambda: x * x + y * y   #注意函数没有参数


	装饰器
		由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。

			>>> def now():
			...     print('2015-3-25')
			...
			>>> f = now
			>>> f()
			2015-3-25
			函数对象有一个__name__属性，可以拿到函数的名字：

			>>> now.__name__
			'now'
			>>> f.__name__
			'now'

		假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

		本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

			def log(func):
			    def wrapper(*args, **kw):  #可接受任意参数调用,但此例无参数
			        print('call %s():' % func.__name__)
			        return func(*args, **kw)
			    return wrapper
		观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

			@log
			def now():
			    print('2015-3-25')
			调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：

			>>> now()
			call now():
			2015-3-25
			把@log放到now()函数的定义处，相当于执行了语句：

			now = log(now)


			还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：

			>>> now.__name__
			'wrapper'
			因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。

		所以完整的代码为
			import functools

			def log(func):
			    @functools.wraps(func)
			    def wrapper(*args, **kw):
			        print('call %s():' % func.__name__)
			        return func(*args, **kw)
			    return wrapper

			@log
			def now():
			    print('2015-3-25')

			now()


		带参数的装饰器
			import functools

			def log(text):
			    def decorator(func):
			        @functools.wraps(func)
			        def wrapper(*args, **kw):
			            print('%s %s():' % (text, func.__name__))
			            return func(*args, **kw)
			        return wrapper
			    return decorator

			@log('execute')
			def now():
			    print('2015-3-25')

			#效果相当于  now = log('execute')(now)，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。


		练习 请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间(自己写的)

			import time

			def count_time(func):
			    def wrap():
			        start = time.time() #时间截(当前秒数)
			        func()             #函数在开始与结束间执行
			        end = time.time()
			        usetime = end - start
			        print('脚本运行所需时间 %.2f' % usetime)
			        
			    return wrap

			@count_time
			def ooo():
			    print('hello')
			    time.sleep(3)   #测试等待3s
			    print('yes')

			ooo()


	偏函数(了解就好)

		通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点

		def int2(x, base=2):     #base默认10进制,我们这里设定为2
		    return int(x, base)
		这样，我们转换二进制就非常方便了：

		>>> int2('1000000')
		64


		通过functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：

		>>> import functools
		>>> int2 = functools.partial(int, base=2)  #感觉就是简化为一行,作用不大
		>>> int2('1000000')
		64


模块
	
	作用
		Python中，一个.py文件就称之为一个模块（Module）

		好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。

		原来了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。如abc.py模块,创建一个顶层包名目录如mymo,那模块名就成为 mymo.abc, 只要顶层包名不冲突,里面的模块都不会冲突.
			包目录里要有一个 __init__.py模块文件,如不存在该目录就被Python视为普通目录，init文件可为空文件或有代码。__init__.py本身就是一个模块，而它的模块名就是mycompany。

		模块名要遵循Python变量命名规范，不要使用中文、特殊字符；
		模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。


	使用模块
		#!/usr/bin/env python3   #linux下让其运行
		# -*- coding: utf-8 -*-    #设置编码

		' a test module '     #模块文件的第一行字符作为注释说明,可不写

		__author__ = 'Michael Liao'  #作者名,可不写

		import sys  #导入sys模块

		def test():
		    args = sys.argv  #sys.argv变量为接收命令行的一个列表,至少有一个参数(模块文件本身)
		    if len(args)==1:
		        print('Hello, world!')
		    elif len(args)==2:
		        print('Hello, %s!' % args[1])
		    else:
		        print('Too many arguments!')

		if __name__=='__main__':  #在命令行运行时,解释器会把__name__设置为__main__,这样就可以运行,从其它地方导入If判断失败
		    test()


		我们可以用命令行运行hello.py看看效果：

		$ python3 hello.py #文件名为hello.py
		Hello, world!
		$ python hello.py Michael
		Hello, Michael!
		如果启动Python交互环境，再导入hello模块：

		$ python3
		Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
		[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
		Type "help", "copyright", "credits" or "license" for more information.
		>>> import hello
		>>>
		导入时，没有打印Hello, word!，因为没有执行test()函数。

		调用hello.test()时，才能打印出Hello, word!：

		>>> hello.test()
		Hello, world!


	作用域
		在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

		正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；

		类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；

		private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

		private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：

			def _private_1(name):
			    return 'Hello, %s' % name

			def _private_2(name):
			    return 'Hi, %s' % name

			def greeting(name):
			    if len(name) > 3:
			        return _private_1(name)
			    else:
			        return _private_2(name)
			我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

			外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public

	安装第三方模块

		pip install 模块  #用pip安装即可

		Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：

		>>> import sys
		>>> sys.path
		['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', 

		.....

		也可以添加目录到sys.path,一是修改sys.path变量,二是修改PYTHONPATH环境变量永久生效


面向对象编程(OOP)
	概念
		是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

		面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。

		而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

		如打印一个学生的成绩, 面向过程的程序设计是这样写

			std1 = {'name': 'xiaoming', 'score': 80}
			std2 = {'name': 'hua', 'score':90}

			def print_socre(std): #传入字典通过key读vlue
				print('%s: %s' % (std['name'], std['score']))

		面向对象是这样写

			class Student(object):   #Student对象

			    def __init__(self, name, score):
			        self.name = name
			        self.score = score

			    def print_score(self): #对象的方法
			        print('%s: %s' % (self.name, self.score))

			bart = Student('Bart', 69)
			lisa = Student('Lisa', 90)

			bart.print_score()
			lisa.print_score()


	类和实例
		面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

		创建类
			class Student(object):  #创建一个Student类,object为所有类都会继承的类(有合适继承的可以不是object)

		    def __init__(self, name, score): #通过__init__方法邦定想要的数据,第一个参数是self,代表创建的实例本身,在init内部就可以把各种属性邦定到self
		        self.name = name
		        self.score = score


		    有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：

			>>> bart = Student('Bart Simpson', 59) #创建实例 类名 + ()
			>>> bart.name
			'Bart Simpson'
			>>> bart.score
			59

		
		数据封装

			和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数

				class Student(object):

				    def __init__(self, name, score):
				        self.name = name
				        self.score = score

				    def print_score(self):  #类的方法
				        print('%s: %s' % (self.name, self.score))


				>>> bart = Student('Bart Simpson', 59) 
				>>> bart.print_score()
				Bart Simpson: 59

				我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。

		访问限制
			如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：

				class Student(object):

				    def __init__(self, name, score):
				        self.__name = name
				        self.__score = score

				    def print_score(self):
				        print('%s: %s' % (self.__name, self.__score))
				改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：

				>>> bart = Student('Bart Simpson', 59)
				>>> bart.__name
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				AttributeError: 'Student' object has no attribute '__name'

			但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：

				class Student(object):
				    ...

				    def get_name(self):
				        return self.__name

				    def get_score(self):
				        return self.__score

			如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：

				class Student(object):
				    ...

				    def set_score(self, score):  #可以添加score值判断如 0<=score<=100,否则抛出异常
				        self.__score = score

			需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。

			有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

			双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：

				>>> bart._Student__name
				'Bart Simpson'
				但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。


			最后注意下面的这种错误写法：

				>>> bart = Student('Bart Simpson', 59)
				>>> bart.get_name()
				'Bart Simpson'
				>>> bart.__name = 'New Name' # 设置__name变量！
				>>> bart.__name
				'New Name'
				表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：

				>>> bart.get_name() # get_name()内部返回self.__name
				'Bart Simpson'


		继承与多态
			class Animal(object):
			    def run(self):
			        print('Animal is running...')
			当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：

			class Dog(Animal):
			    pass

			class Cat(Animal):
			    pass
			对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。

			继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：

			dog = Dog()
			dog.run()

			cat = Cat()
			cat.run()
			运行结果如下：

			Animal is running...
			Animal is running...

			子类重新写方法

				class Dog(Animal):

				    def run(self):
				        print('Dog is running...')

				class Cat(Animal):

				    def run(self):
				        print('Cat is running...')
				再次运行，结果如下：

				Dog is running...
				Cat is running...
				当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。

			多态
				class Animal:

				    def kind(self):
				        print("i am animal")


				class Dog(Animal):

				    def kind(self):
				        print("i am a dog")


				class Cat(Animal):

				    def kind(self):
				        print("i am a cat")


				class Pig(Animal):

				    def kind(self):
				        print("i am a pig")

				# 这个函数接收一个animal参数，并调用它的kind方法
				def show_kind(animal):
				    animal.kind()


				d = Dog()
				c = Cat()
				p = Pig()

				show_kind(d)
				show_kind(c)
				show_kind(p)

				------------------
				打印结果：

				i am a dog
				i am a cat
				i am a pig
				狗、猫、猪都继承了动物类，并各自重写了kind方法。show_kind()函数接收一个animal参数，并调用它的kind方法。可以看出，无论我们给animal传递的是狗、猫还是猪，都能正确的调用相应的方法，打印对应的信息。这就是多态

				实际上，由于Python的动态语言特性，传递给函数show_kind()的参数animal可以是 任何的类型，只要它有一个kind()的方法即可。动态语言调用实例方法时不检查类型，只要方法存在，参数正确，就可以调用。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

					class Job（object):

					    def kind(self):
					        print("i am not animal, i am a job")

					j = Job()
					show_kind(j)



		获取对象信息
			使用type()
				首先，我们来判断对象类型，使用type()函数：

				基本类型都可以用type()判断：

					>>> type(123)
					<class 'int'>
					>>> type('str')
					<class 'str'>
					>>> type(None)
					<type(None) 'NoneType'>
					>>> type(abs)
					<class 'builtin_function_or_method'>

				但是type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：

					>>> type(123)==type(456)
					True
					>>> type(123)==int
					True
					>>> type('abc')==type('123')
					True
					>>> type('abc')==str
					True

				如果要判断一个对象是否是函数(内建函数,匿名函数等)怎么办？可以使用types模块中定义的常量：

					>>> import types
					>>> def fn():
					...     pass
					...
					>>> type(fn)==types.FunctionType
					True
					>>> type(lambda x: x)==types.LambdaType
					True
					#其它略过

			使用isinstance()
				isinstance()也可以用作type()判断基本类型
				对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。

				我们回顾上次的例子，如果继承关系是：

				object -> Animal -> Dog -> Husky
				那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：

				>>> a = Animal()
				>>> d = Dog()
				>>> h = Husky()
				然后，判断：

				>>> isinstance(h, Husky)
				True
				没有问题，因为h变量指向的就是Husky对象。

				再判断：

				>>> isinstance(h, Dog)
				True

				同理h也是属于Animal, 但是a不属于Dog

				并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：

				>>> isinstance([1, 2, 3], (list, tuple))
				True

		dir()

			如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：

			>>> dir('ABC')
			['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
			类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：

				>>> len('ABC')
				3
				>>> 'ABC'.__len__()
				3

			我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：

				>>> class MyDog(object):
				...     def __len__(self):
				...         return 100
				...
				>>> dog = MyDog()
				>>> len(dog)
				100

			剩下的都是普通属性或方法，比如lower()返回小写的字符串：

				>>> 'ABC'.lower()
				'abc'

			仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象(列表元组类等)的状态：

				>>> class MyObject(object):
				...     def __init__(self):
				...         self.x = 9
				...     def power(self):
				...         return self.x * self.x
				...
				>>> obj = MyObject()
			紧接着，可以测试该对象的属性：

				>>> hasattr(obj, 'x') # 有属性'x'吗？
				True
				>>> obj.x
				9
				>>> hasattr(obj, 'y') # 有属性'y'吗？
				False
				>>> setattr(obj, 'y', 19) # 设置一个属性'y'
				>>> hasattr(obj, 'y') # 有属性'y'吗？
				True
				>>> getattr(obj, 'y') # 获取属性'y'
				19
				>>> obj.y # 获取属性'y'
				19
			如果试图获取不存在的属性，会抛出AttributeError的错误：

				>>> getattr(obj, 'z') # 获取属性'z'
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				AttributeError: 'MyObject' object has no attribute 'z'
				可以传入一个default参数，如果属性不存在，就返回默认值：

				>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
				404
			也可以获得对象的方法：

				>>> hasattr(obj, 'power') # 有属性'power'吗？
				True
				>>> getattr(obj, 'power') # 获取属性'power'
				<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
				>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
				>>> fn # fn指向obj.power
				<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
				>>> fn() # 调用fn()与调用obj.power()是一样的
				81

			列表元组等查看
				>>> hasattr('abc', '__len__')
				True
				>>> hasattr([1,2,3], 'pop')
				True

			通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：

			sum = obj.x + obj.y
			就不要写：

			sum = getattr(obj, 'x') + getattr(obj, 'y')
			一个正确的用法的例子如下：

			def readImage(fp):
			    if hasattr(fp, 'read'): #先判断fp是否存在read方法再执行
			        return readData(fp)
			    return None


		实例属性与类属性

			给实例绑定属性的方法是通过实例变量，或者通过self变量：

				class Student(object):
				    def __init__(self, name):
				        self.name = name  #通过self邦定实例属性

				s = Student('Bob')
				s.score = 90   #通守实例变量邦定实例属性

			但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：

				class Student(object):
				    name = 'Student'
				当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：

				>>> class Student(object):
				...     name = 'Student'
				...
				>>> s = Student() # 创建实例s
				>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
				Student
				>>> print(Student.name) # 打印类的name属性
				Student
				>>> s.name = 'Michael' # 给实例绑定name属性
				>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
				Michael
				>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
				Student
				>>> del s.name # 如果删除实例的name属性
				>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
				Student
				从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。


面象对象高级编程
	
	使用__slots__

		正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：

			class Student(object):
			    pass
		然后，尝试给实例绑定一个属性：

			>>> s = Student()
			>>> s.name = 'Michael' # 动态给实例绑定一个属性
			>>> print(s.name)
			Michael
		还可以尝试给实例绑定一个方法：

			>>> def set_age(self, age): # 定义一个函数作为实例方法
			...     self.age = age
			...
			>>> from types import MethodType
			>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
			>>> s.set_age(25) # 调用实例方法
			>>> s.age # 测试结果
			25

		但是，给一个实例绑定的方法，对另一个实例是不起作用的：

			>>> s2 = Student() # 创建新的实例
			>>> s2.set_age(25) # 尝试调用方法
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			AttributeError: 'Student' object has no attribute 'set_age'

		为了给所有实例都绑定方法，可以给class绑定方法：

			>>> def set_score(self, score):
			...     self.score = score
			...
			>>> Student.set_score = set_score
		给class绑定方法后，所有实例均可调用：

			>>> s.set_score(100)
			>>> s.score
			100
			>>> s2.set_score(99)
			>>> s2.score
			99
		通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。

		__slots__

			如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。

			为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：

				class Student(object):
				    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
			然后，我们试试：

				>>> s = Student() # 创建新的实例
				>>> s.name = 'Michael' # 绑定属性'name'
				>>> s.age = 25 # 绑定属性'age'
				>>> s.score = 99 # 绑定属性'score'
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				AttributeError: 'Student' object has no attribute 'score'
			由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。

			使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的


	使用@property
		Python内置的@property装饰器就是负责把一个方法变成属性调用的：

		class Student(object):

		    @property
		    def score(self):
		        return self._score

		    @score.setter
		    def score(self, value):
		        if not isinstance(value, int):
		            raise ValueError('score must be an integer!')
		        if value < 0 or value > 100:
		            raise ValueError('score must between 0 ~ 100!')
		        self._score = value

		@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

		>>> s = Student()
		>>> s.score = 60 # OK，实际转化为s.set_score(60)
		>>> s.score # OK，实际转化为s.get_score()
		60
		>>> s.score = 9999
		Traceback (most recent call last):
		  ...
		ValueError: score must between 0 ~ 100!
		注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。

		还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：

		class Student(object):

		    @property
		    def birth(self):
		        return self._birth

		    @birth.setter
		    def birth(self, value):
		        self._birth = value

		    @property
		    def age(self):
		        return 2015 - self._birth


	多重继承

		动物的分类

			class Animal(object):
			    pass

			# 大类:
			class Mammal(Animal):
			    pass

			class Bird(Animal):
			    pass

			# 各种动物:
			class Dog(Mammal):
			    pass

			class Bat(Mammal):
			    pass

			class Parrot(Bird):
			    pass

			class Ostrich(Bird):
			    pass
		现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：

			class Runnable(object):
			    def run(self):
			        print('Running...')

			class Flyable(object):
			    def fly(self):
			        print('Flying...')
		对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：

			class Dog(Mammal, Runnable):
			    pass

		 通过多重继承，一个子类就可以同时获得多个父类的所有功能,Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。

		 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

		 举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。

		比如，编写一个多进程模式的TCP服务，定义如下：

			class MyTCPServer(TCPServer, ForkingMixIn): #功能一tcpserver, 功能二 多进程
			    pass
		编写一个多线程模式的UDP服务，定义如下：

			class MyUDPServer(UDPServer, ThreadingMixIn):
			    pass


	定制类

		__str__

			>>> class Student(object):
			...     def __init__(self, name):
			...         self.name = name
			...
			>>> print(Student('Michael')) #直接打印实例,没有赋值实例给变量
			<__main__.Student object at 0x109afb190>
			打印出一堆<__main__.Student object at 0x109afb190>，不好看。

			怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：

			>>> class Student(object):
			...     def __init__(self, name):
			...         self.name = name
			...     def __str__(self):   # __str__ 返回用户看到的数据
			...         return 'Student object (name: %s)' % self.name
			...
			>>> print(Student('Michael'))
			Student object (name: Michael)


			但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看： (了解即可)

				>>> s = Student('Michael')
				>>> s
				<__main__.Student object at 0x109afb310>
				这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。

				解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：

				class Student(object):
				    def __init__(self, name):
				        self.name = name
				    def __str__(self):
				        return 'Student object (name=%s)' % self.name
				    __repr__ = __str__  