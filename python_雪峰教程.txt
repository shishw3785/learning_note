python简介
	连google都在大规模使用,不用担心学了没用
	当用一种语言开始软件开发时,除了编写代码外,还需要很多基本已经这好的东西加速开发,如开发一个邮件客户端,如果从最底层开始编写网络协议相关的代码可能要一年多也不行.高级语言通常会提供一个比较完善的基础代码库,可以直接调用.如由件协议的SMTP库,我们就可以在现有代码库上开发,短时间就能写邮件客户端软件出来

	python提供了非常完善的基础代码库,包括网络,文件,GUI,数据库等和第三方库,可以直接使用

	优点
		简洁,高效
	缺点
		运行速度慢,因为是解释型语言,代码在执行时会一行一行地翻译成CPU能理解的机器码

python解释器
	当编写python代码时,得到的是一个.py扩展名的文本文件,要运行代码,就需要python解释器去执行

	官网安装Python后就得到了一个官方解释器材cpython(使用最广),用c语言开发,在命令行下python就启动cpython了

输入和输出
	>>> print('hello, world')
	hello, world

	>>> print('hello', 'world')
	hello world    #print接受多个字符,用逗号隔开,打印时每遇一个, 就会输出一个空格

	print()也可以打印整数，或者计算结果：

	>>> print(300)
	300
	>>> print(100 + 200)
	300

	>>> print('100 + 200 =', 100 + 200)
	100 + 200 = 300

	输入
	>>> name = input()
	Michael
	>>> name
	'Michael'

	>>> name = input('please enter your name: ') #显示字符串提醒
	please enter your name: leison
	>>> print('hello', name)
	hello leison

python基础
	任何一种语言都有一套语法,编译器或解释器就是把符合语法的代码转译给CPU能识别的机器码

	# 开头是注释
	每一行都是一个语句,语句以冒号 : 结尾时,缩进的语句称为代码块,应以4个空格缩进,好处是让长语句缩短成短语句,缺点是复制后的代码要重新检验缩进标准

	数据类型,Python能直接处理的数据类型
		整数
			可以处理任意大意的整数,包括负整数
				1 100 -8 0
			十六进制
				十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

		浮点数
			1.23，3.14，-9.01
			很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等

			整数和浮点数在计算机内部存储方式不同,整数是精确的,而浮点数有时要四舍五入

		字符串
			以'' 或 "" 括起来的任意文本
				'abc'
				"Im' ok" # 单引号本身也是字符,用双引号括起来,里面的空格也是字符
				空字符串 ' ' #注意空格

			转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：

			>>> print('I\'m ok.')
			I'm ok.
			>>> print('I\'m learning\nPython.')
			I'm learning
			Python.
			>>> print('\\\n\\')
			\
			\
			如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：

			>>> print('\\\t\\')
			\       \
			>>> print(r'\\\t\\')
			\\\t\\

			如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：

			>>> print('''line1
			... line2
			... line3''')
			line1
			line2
			line3

		布尔值
			只有True和False,要么是True要么是False

			>>> True
			True
			>>> False
			False
			>>> 3 > 2
			True
			>>> 3 > 5
			False

			布尔值可以用and、or和not运算。

			and运算是与运算，只有所有都为True，and运算结果才是True：

			>>> True and True
			True
			>>> True and False
			False
			>>> False and False
			False
			>>> 5 > 3 and 3 > 1
			True
			or运算是或运算，只要其中有一个为True，or运算结果就是True：

			>>> True or True
			True
			>>> True or False
			True
			>>> False or False
			False
			>>> 5 > 3 or 1 > 3
			True

			not运算是非运算，它是一个单目运算符，把True变成False，False变成True：

			>>> not True
			False
			>>> not False
			True
			>>> not 1 > 2
			True

		空值
			特殊值,用None表示,不能理解为0,因为0有意义

		变量
			等号 = 是赋值语句,可以把任意数据类型赋值给变量
			变量名必须是英文数字与_的组合,不能是数字开头

			a = 1
			变量a是一个整数。

			原理,在内容中创建数据1,在内存中创建变量且名a并把它指向数据1

			t_007 = 'T007'
			变量t_007是一个字符串。

			Answer = True
			变量Answer是一个布尔值True。

		python是动态语言
			a = 1
			a = 'abc'
			变量可以赋值任何类型(不固定),所以是动态固语言,灵活,JAVA是静态语言变量要先定义数据类型如int a = 1

		赋值 = 
			x = 10
			x = x + 2  --> x =12
			=不是数学常识的=号,而是赋值的意思

		常量
			通常用大写表示
			如 PI = 3.1415926

		/ 除法
			/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

			>>> 9 / 3
			3.0
			还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

			>>> 10 // 3
			3
		 % 求余
		 	>>> 10 % 3
			1

字符串和编码
	
	编码
	Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
	Unicode编码转化为“可变长编码”的UTF-8编码

	在内存中,统一用Unicode编码,当需要保存到硬盘或传输时(浏览器转输内容)就换UTF-8编码

	python字符串
		在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：

		>>> print('包含中文的str')
		包含中文的str
		对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

		>>> ord('A')
		65
		>>> ord('中')
		20013
		>>> chr(66)
		'B'
		>>> chr(25991)
		'文'

		如果知道字符的整数编码，还可以用十六进制这么写str：

		>>> '\u4e2d\u6587'
		'中文'

		由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

		Python对bytes类型的数据用带b前缀的单引号或双引号表示：

		x = b'ABC'
		要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。(节省了空间)

		以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

		>>> 'ABC'.encode('ascii')
		b'ABC'
		>>> '中文'.encode('utf-8')
		b'\xe4\xb8\xad\xe6\x96\x87'
		>>> '中文'.encode('ascii')
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
		纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

		反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

		>>> b'ABC'.decode('ascii')
		'ABC'
		>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
		'中文'
		如果bytes中包含无法解码的字节，decode()方法会报错：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
		Traceback (most recent call last):
		  ...
		UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
		如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
		'中'

		要计算str包含多少个字符，可以用len()函数：

		>>> len('ABC')
		3
		>>> len('中文')
		2
		len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

		>>> len(b'ABC')
		3
		>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
		6
		>>> len('中文'.encode('utf-8'))  #encode转成bytes类型
		6
		可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

		python保存的文本如果包含中文要在文件头添加
		#!/usr/bin/env python3  #linux 设置
		# -*- coding: utf-8 -*-   #编码设置
		并且文本编译软件设置选择UTF-8 without BOM编码



		格式化输出
		>>> 'Hello, %s' % 'world'
		'Hello, world'
		>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
		'Hi, Michael, you have $1000000.'
		你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

		补位
		>>> print('%2d-%02d' % (3,1))
		3-01
		>>> print('%.2f' % 3.1415)
		3.14

		需要 %字符,可以通过%转义
		>>> 'growth rate: %d %%' % 7
		'growth rate: 7 %'

		format()也可以格式化输出


list和tuple 
	列表是同置的一种内置的数据类型,有序的集合,可以随时添加和删除其中的元素

	>>> classmates = ['Michael', 'Bob', 'Tracy']
	>>> classmates
	['Michael', 'Bob', 'Tracy']

	可以用len()函数计算里面的个数
	>>> len(classmates)
	3

	用索引来访问里面元素,从0开始
	>>> classmates[0]
	'Michael'
	>>> classmates[1]
	'Bob'
	>>> classmates[2]
	'Tracy'
	>>> classmates[3]
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	IndexError: list index out of range

	取最后一个元素
	classmates[-1]
	>>>'Tracy'
	以此类推可以获取倒数的元素-2,-3

	List是可变的元素,可以追加素到末尾
	classmates.append('Adm')
	>>> classmates
	['Michael', 'Bob', 'Tracy', 'Adam']

	也可以把元素插入指定位置,比如索引1的位置
	classmates.insert(1,'Jack')
	['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']

	删除List末尾元素
	classmates.pop()
	'Adam'
	>>> classmates
	['Michael', 'Jack', 'Bob', 'Tracy']

	删除指定位置元素,pop(i)
	classmates.pop(1)
	['Michael', 'Bob', 'Tracy']

	元素替换
	classmates[1] = 'Sarah'
	['Michael', 'Sarah', 'Tracy']

	list元素的数据类型也可以不同
	L = ['Apple', 123, True ]

	list元素也可以是另一个List
	s = ['python', 'java', ['asp', 'php'], 'sql']

	p = ['asp', 'php']
	s = ['python', 'java', p, 'sql']  #元素也可以是变量

	len(s)
	4

	s[2][1] 或p[1]
	>>> 'php'

	空list
	L = []
	len(L)
	>>> 0 

	tuple元组
		有序不可变,一旦初始化就不能修改

		classmates = ('Michael', 'Bob', 'Tracy')
		可以通过 classmates[i] 索引读取数据

		但是不能变了,没有append(),insert(),也不能重新赋值classmates[1] = 'hello'

		空的tuple，可以写成()：

			>>> t = ()
			>>> t
			()

		"可变的元组"
		>>> t = ('a', 'b', ['A', 'B'])
		>>> t[2][0] = 'X'
		>>> t[2][1] = 'Y'
		>>> t
		('a', 'b', ['X', 'Y'])
		#不可变指的是元素的指向不可变,但元素本身是List它是可变的

条件判断
	if语句

		if <条件判断1>:
		    <执行1>
		elif <条件判断2>:
		    <执行2>
		elif <条件判断3>:
		    <执行3>
		else:
		    <执行4>

	例
	age = 16
	if age > 18:
	    print('adult', 'you age is', age)
	elif age < 18:
	    print('baby', 'you age is', age)
	else:
	    print('i dont know')

	 简写
	 	if x:
		    print('True')
		只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。

	结合input()
		s = input('birth: ')
		birth = int(s)   #利用int()把str转成整数类型
		if birth < 2000:
		    print('00前')
		else:
		    print('00后')


循环
	for循环

	for x in ...循环就是把每个元素(可以是列表或元组的元素)代入变量x，然后执行缩进块的语句。

		例
		sum = 0
		for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
		    sum = sum + x
		print(sum)

		range()函数可以生成整数序列,利用list()函数可以让其转成列表
		>>> list(range(5))    #从0开始小于5的整数
		[0, 1, 2, 3, 4]


	while循环
		while循环，只要条件满足，就不断循环，条件不满足时退出循环

		例
		sum = 0
		n = 99
		while n > 0:
		    sum = sum + n
		    n = n - 2
		print(sum)

	break语句
		提前结束循环

		n = 1
		while n <= 100:
		    if n > 10: # 当n = 11时，条件满足，执行break语句
		        break # break语句会结束当前循环
		    print(n)
		    n = n + 1
		print('END')

	continue
		通过continue语句，跳过当前的这次循环，直接开始下一次循环。

		n = 0
		while n < 10:
		    n = n + 1
		    if n % 2 == 0: # 如果n是偶数，执行continue语句
		        continue   #语句会直接继续下一轮循环，后续的print()语句不会执行
		    print(n)


字典dic 与 set

	字典
		>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}  #创建字典
		>>> d['Michael']
		95

		#key-value存储方式 查询速度快

		把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

		>>> d['Adam'] = 67   #额外添加键值
		>>> d['Adam']
		67
		由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

		>>> d['Jack'] = 90     
		>>> d['Jack']
		90
		>>> d['Jack'] = 88    #修改值
		>>> d['Jack']
		88

		要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：

		>>> 'Thomas' in d
		False
		二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：

		>>> d.get('Thomas')
		>>> d.get('Thomas', -1)
		-1
		注意：返回None的时候Python的交互环境不显示结果。

		要删除一个key，用pop(key)方法，对应的value也会从dict中删除：

		>>> d.pop('Bob')
		75
		>>> d
		{'Michael': 95, 'Tracy': 85}

		请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

		和list比较，dict有以下几个特点：

		查找和插入的速度极快，不会随着key的增加而变慢；
		需要占用大量的内存，内存浪费多。
		而list相反：

		查找和插入的时间随着元素的增加而增加；
		占用空间小，浪费内存很少。
		所以，dict是用空间来换取时间的一种方法

		dic 的key必须是不可变的对象,通过key计算出velue称做哈希算法
			字符串与整数是不可变的,可以做为key值
			list是可变的,不能做key值

	set
		set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

		要创建一个set，需要提供一个list作为输入集合：

		>>> s = set([1, 2, 3])
		>>> s
		{1, 2, 3}
		注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

		重复元素在set中自动被过滤：

		>>> s = set([1, 1, 2, 2, 3, 3])
		>>> s
		{1, 2, 3}
		通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		通过remove(key)方法可以删除元素：

		>>> s.remove(4)
		>>> s
		{1, 2, 3}
		set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

		>>> s1 = set([1, 2, 3])
		>>> s2 = set([2, 3, 4])
		>>> s1 & s2
		{2, 3}
		>>> s1 | s2
		{1, 2, 3, 4}
		set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象

		对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：

		>>> a = ['c', 'b', 'a']
		>>> a.sort()
		>>> a
		['a', 'b', 'c']
		而对于不可变对象，比如str，对str进行操作呢：

		>>> a = 'abc'
		>>> a.replace('a', 'A')
		'Abc'
		>>> a
		'abc'             #虽然有replace方法,但a的变量内容还是不变的


函数
	调用函数
		调用abs函数：

		求绝对值
		>>> abs(100)
		100
		>>> abs(-20)
		20

		max函数max()可以接收任意多个参数，并返回最大的那个：

		>>> max(1, 2)
		2
		>>> max(2, 3, 1, -5)
		3

		数据类型转换
		>>> int('123')
		123
		>>> int(12.34)
		12
		>>> float('12.34')
		12.34
		>>> str(1.23)
		'1.23'
		>>> str(100)
		'100'
		>>> bool(1)
		True
		>>> bool('')   #整数0也是False
		False

		函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

		>>> a = abs # 变量a指向abs函数
		>>> a(-1) # 所以也可以通过a调用abs函数
		1

		调用函数要传入正确的参数,否则会出错,可以看错误信息


	定义函数
		def my_abs(x):
		    if x >= 0:
		        return x
		    else:
		        return -x

		print(my_abs(-99))

		用def语句, 函数名my_abs, x参数 , : 冒号  缩进语中编写函数体, 用 return 返回函数值

		一旦遇到return 时,函数就执行完毕,并将结果返回, 如果没有return语句,函数执行完毕也会返回结果,只是结果为 None,  return None 可以简写为 return

		把my_abs()函数定义保存为abstest.py文件,那么可以在该文件的当前目录下启动python解释器, 用  from abstest import my_abs 来导入my_abs()函数,注意是 abstest不包含  .py

		空函数
			定义一个函数什么事也不想做

			def nop():
				pass

			pass语句什么都不做,作用,作为占位符,如还没想好怎么写代码,可以放pass,让代码先能运行起来, pass 也可以放在其他语句中

			if age >= 18:
				pass	

			修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：

				def my_abs(x):
				    if not isinstance(x, (int, float)):
				        raise TypeError('bad operand type')
				    if x >= 0:
				        return x
				    else:
				        return -x

		返回多个值
			import math

			def move(x, y, step, angle=0):
			    nx = x + step * math.cos(angle)
			    ny = y - step * math.sin(angle)
			    return nx, ny

			>>> x, y = move(100, 100, 60, math.pi / 6)
			>>> print(x, y)
			151.96152422706632 70.0
			但其实这只是一种假象，Python函数返回的仍然是单一值：

			>>> r = move(100, 100, 60, math.pi / 6)
			>>> print(r)
			(151.96152422706632, 70.0)
			其实返回的是一个元组


	函数的参数
		计算x4、x5…

		def power(x, n):
		    s = 1
		    while n > 0:
		        n = n - 1
		        s = s * x
		    return s

		默认参数
			def power(x, n=2):
			    s = 1
			    while n > 0:
			        n = n - 1
			        s = s * x
			    return s
			这样，当我们调用power(5)时，相当于调用power(5, 2)：

			>>> power(5)
			25
			>>> power(5, 2)
			25

			注意：

				一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

				二是如何设置默认参数。

				当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

				使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

			def enroll(name, gender, age=6, city='Beijing'):
			    print('name:', name)
			    print('gender:', gender)
			    print('age:', age)
			    print('city:', city)
			这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：

			>>> enroll('Sarah', 'F')
			name: Sarah
			gender: F
			age: 6
			city: Beijing

			只有与默认参数不符的学生才需要提供额外的信息：

			enroll('Bob', 'M', 7) # city没有取值,使用默认值
			enroll('Adam', 'M', city='Tianjin')  #不按顺序设值要指名参数名city

			定义默认参数要牢记一点：默认参数必须指向不变对象！

			def add_end(L=None):                   #在如果 L = [],每次add_end()后L都会添加END
			    if L is None:
			        L = []
			    L.append('END')
			    return L
			现在，无论调用多少次，都不会有问题：

			>>> add_end()
			['END']
			>>> add_end()
			['END']

		可变参数
			如若要算a*a + b*b + c*c....

			def calc(numbers):
			    sum = 0
			    for n in numbers:
			        sum = sum + n * n
			    return sum
			但是调用的时候，需要先组装出一个list或tuple：

			>>> calc([1, 2, 3])
			14
			>>> calc((1, 3, 5, 7))
			84

			我们把函数的参数改为可变参数：

			def calc(*numbers):            #在函数内部numbers接收到的是一个tuple,可传入任意个参数
			    sum = 0
			    for n in numbers:
			        sum = sum + n * n
			    return sum

			调用函数的方式可以简化成这样：

			>>> calc(1, 2, 3)
			14
			>>> calc(1, 3, 5, 7)
			84

			Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：

			>>> nums = [1, 2, 3]
			>>> calc(*nums)
			14

		关键字参数
			可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：

			def person(name, age, **kw):
			    print('name:', name, 'age:', age, 'other:', kw)
			函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：

			>>> person('Michael', 30)
			name: Michael age: 30 other: {}
			也可以传入任意个数的关键字参数：

			>>> person('Bob', 35, city='Beijing')
			name: Bob age: 35 other: {'city': 'Beijing'}
			>>> person('Adam', 45, gender='M', job='Engineer')
			name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

			和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

			>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
			>>> person('Jack', 24, city=extra['city'], job=extra['job'])
			name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

			当然，上面复杂的调用可以用简化的写法：

			>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
			>>> person('Jack', 24, **extra)
			name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}


		命名关键字参数
			如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：

			def person(name, age, *, city, job):   #如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：
			    print(name, age, city, job)

			和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

			调用方式如下：

			>>> person('Jack', 24, city='Beijing', job='Engineer')  
			Jack 24 Beijing Engineer
			#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

			>>> person('Jack', 24, 'Beijing', 'Engineer')
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: person() takes 2 positional arguments but 4 were given
			由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。

			如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：

			def person(name, age, *args, city, job):
			    print(name, age, args, city, job)

			命名关键字参数可以有缺省值，从而简化调用：

			def person(name, age, *, city='Beijing', job):
			    print(name, age, city, job)
			由于命名关键字参数city具有默认值，调用时，可不传入city参数：

			>>> person('Jack', 24, job='Engineer')
			Jack 24 Beijing Engineer


	递归函数
		在函数内部可以调用其它函数,如果调用的是自己本身,那就是递归函数

		计算n的阶乘 n!=n * (n-1) * (n-2).... * 1
		def fact(n):
		    if n==1:
		        return 1
		    return n * fact(n - 1)

		递归函数优点是逻辑清晰,简单

		使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)

		解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

		尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

		上面的fact(n)函数由于return n * fact(n - 1）引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

		def fact(n):
		    return fact_iter(n, 1)

		def fact_iter(num, product):
		    if num == 1:
		        return product
		    return fact_iter(num - 1, num * product)

		fact(5)对应的fact_iter(5, 1)的调用如下：

		===> fact_iter(5, 1)
		===> fact_iter(4, 5)
		===> fact_iter(3, 20)
		===> fact_iter(2, 60)
		===> fact_iter(1, 120)
		===> 120               #return 120(product)


高级特性 切片
	
	>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
	>>> L[0:3]
	['Michael', 'Sarah', 'Tracy']

	L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。

	如果第一个索引是0，还可以省略：

	>>> L[:3]
	['Michael', 'Sarah', 'Tracy']
	也可以从索引1开始，取出2个元素出来：

	>>> L[1:3]
	['Sarah', 'Tracy']

	类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：

	>>> L[-2:]
	['Bob', 'Jack']
	>>> L[-2:-1]
	['Bob']

	切片操作十分有用。我们先创建一个0-99的数列：

	>>> L = list(range(100))
	>>> L
	[0, 1, 2, 3, ..., 99]
	可以通过切片轻松取出某一段数列。比如前10个数：

	>>> L[:10]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

	前10个数，每两个取一个：

	>>> L[:10:2]
	[0, 2, 4, 6, 8]
	所有数，每5个取一个：

	>>> L[::5]
	[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
	甚至什么都不写，只写[:]就可以原样复制一个list：

	>>> L[:]
	[0, 1, 2, 3, ..., 99]

	tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：

	>>> (0, 1, 2, 3, 4, 5)[:3]
	(0, 1, 2)
	字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：

	>>> 'ABCDEFG'[:3]
	'ABC'
	>>> 'ABCDEFG'[::2]
	'ACEG'

高级特性 迭代
	Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上

	只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
		>>> d = {'a': 1, 'b': 2, 'c': 3}
		>>> for key in d:
		...     print(key)
		...
		a
		c
		b

	因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

	默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()

	字符串也可以迭代

	判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：

		>>> from collections import Iterable
		>>> isinstance('abc', Iterable) # str是否可迭代
		True
		>>> isinstance([1,2,3], Iterable) # list是否可迭代
		True
		>>> isinstance(123, Iterable) # 整数是否可迭代
		False

	Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

		>>> for i, value in enumerate(['A', 'B', 'C']):
		...     print(i, value)
		...
		0 A
		1 B
		2 C


高级特性 列表生成式
	>>> [x * x for x in range(1, 11)]
	[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
	写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环

	for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

	>>> [x * x for x in range(1, 11) if x % 2 == 0]
	[4, 16, 36, 64, 100]

	for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：

	>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
	>>> for k, v in d.items():
	...     print(k, '=', v)
	...
	y = B
	x = A
	z = C

	因此，列表生成式也可以使用两个变量来生成list：

	>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
	>>> [k + '=' + v for k, v in d.items()]
	['y=B', 'x=A', 'z=C']

	最后把一个list中所有的字符串变成小写：

	>>> L = ['Hello', 'World', 'IBM', 'Apple']
	>>> [s.lower() for s in L]


	在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else

	>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
	[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]


高级特性 生成器

	按照某种算法,一边循环一边计算的机制,称为生成器(generator)
	
	要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

		>>> L = [x * x for x in range(10)]
		>>> L
		[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
		>>> g = (x * x for x in range(10))
		>>> g
		<generator object <genexpr> at 0x1022ef630>

	如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：

		>>> next(g)
		0
		>>> next(g)
		1
		>>> next(g)
		4
		>>> next(g)
		9
		>>> next(g)
		16
		>>> next(g)
		25
		>>> next(g)
		36
		>>> next(g)
		49
		>>> next(g)
		64
		>>> next(g)
		81
		>>> next(g)
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		StopIteration
		我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。

	一般都是用for循环打印
		for i in g:
			print(i)

		for循环不用关心会抛出错误

	著名的斐波拉契数列 用函数表示
		def fib(max):
		    n, a, b = 0, 0, 1
		    while n < max:
		        print(b)
		        a, b = b, a + b
		        n = n + 1
		    return 'done'

		要把fib函数变成generator，只需要把print(b)改为yield b就可以了(因为这数据就是类似生成器)：

			def fib(max):
			    n, a, b = 0, 0, 1
			    while n < max:
			        yield b
			        a, b = b, a + b
			        n = n + 1
			    return 'done'

		这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：

		>>> f = fib(6)
		>>> f
		<generator object fib at 0x104feaaa0>

	函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

		举个简单的例子，定义一个generator，依次返回数字1，3，5：

			def odd():
			    print('step 1')
			    yield 1
			    print('step 2')
			    yield(3)
			    print('step 3')
			    yield(5)
		调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：

			>>> o = odd()
			>>> next(o)
			step 1
			1
			>>> next(o)
			step 2
			3
			>>> next(o)
			step 3
			5
			>>> next(o)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			StopIteration


	但一般是用for来返回
		>>> for n in fib(6):
		...     print(n)
		...
		1
		...

		如要取得return 的‘done'值,就要捕获错误,先略过

高级特性 迭代器
	这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

		可以使用isinstance()判断一个对象是否是Iterable对象：

		>>> from collections.abc import Iterable
		>>> isinstance([], Iterable)
		True
		>>> isinstance({}, Iterable)
		True
		>>> isinstance('abc', Iterable)
		True
		>>> isinstance((x for x in range(10)), Iterable)
		True
		>>> isinstance(100, Iterable)
		False

	可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

		可以使用isinstance()判断一个对象是否是Iterator对象：

		>>> from collections.abc import Iterator
		>>> isinstance((x for x in range(10)), Iterator)
		True
		>>> isinstance([], Iterator)
		False
		>>> isinstance({}, Iterator)
		False

	生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值

	把list、dict、str等Iterable变成Iterator可以使用iter()函数：

		>>> isinstance(iter([]), Iterator)
		True
		>>> isinstance(iter('abc'), Iterator)
		True


函数式编程
	函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。

	函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量

	函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！

	Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。


	高阶函数

		变量可以指向函数

			>>> abs(-10)
			10
			但是，如果只写abs呢？

			>>> abs
			<built-in function abs>
			可见，abs(-10)是函数调用，而abs是函数本身。

			要获得函数调用结果，我们可以把结果赋值给变量：

			>>> x = abs(-10)
			>>> x
			10
			但是，如果把函数本身赋值给变量呢？

			>>> f = abs
			>>> f
			<built-in function abs>
			结论：函数本身也可以赋值给变量，即：变量可以指向函数。

			>>> f = abs
			>>> f(-10)
			10
			成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。

		函数名也是变量名

			>>> abs = 10
			>>> abs(-10)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: 'int' object is not callable
			把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！

		传入函数
			既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

			一个最简单的高阶函数：

			def add(x, y, f):
			    return f(x) + f(y)
			当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：

			x = -5
			y = 6
			f = abs
			f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
			return 11


	map() 与 reduce()
		map()
			该函数接接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回

			如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上,让其变成 [1, 4, 9, 16, 25, 36, 49, 64, 81]

			>>> def f(x):
			...     return x * x
			...
			>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
			>>> list(r)
			[1, 4, 9, 16, 25, 36, 49, 64, 81]

		reduce()
			reduce()接收两个参数,一个是函数(必须接收两个参数),另一个是序列(iterable),函数作用后的结果继续和序列的下一个元素作累积计算,然后把结果返回


			求和

				>> reduce(add, [1,2,3,4,5])  #add函数只接收两个参数  先是add(1,2)-->add(3,3)-->add(6,4)-->add(10,5)
				15



			如把str转成int
				
				from functools import reduce

				dic = {'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}

				s = '13579'

				def yes(s):
				    def f(x, y):
				        return x * 10 + y
				    def ooo(n):
				        return dic[n]
				    return reduce(f, map(ooo, s))

				print(yes(s))


	filter()
		Python内建的filter()函数用于过滤序列。

		和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

		例如，在一个list中，删掉偶数，只保留奇数，可以这么写：

		def is_odd(n):
		    return n % 2 == 1

		list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
		# 结果: [1, 5, 9, 15]

		其它先略过

	sorted()
		对list进行排序

		>>> sorted([36, 5, -12, 9, -21])
		[-21, -12, 5, 9, 36]

		sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：

		>>> sorted([36, 5, -12, 9, -21], key=abs)
		[5, 9, -12, -21, 36]

		给sorted传入key函数，即可实现忽略大小写的排序：

		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)  #比对第一个字母
		['about', 'bob', 'Credit', 'Zoo']
		要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：

		>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
		['Zoo', 'Credit', 'bob', 'about']

		练习假设我们用一组tuple表示学生名字和成绩：

		L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
		请用sorted()对上述列表分别按名字排序：

			L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

			d = {}

			for x,y in L:   #换成字典对应
			    d[x] = y   

			def f(n):
			    t = []
			    s = []
			    for i in n:      #把要排序的值整合到t列表
			        t.append(i[0])
			    for x in sorted(t, key=str.lower): #按首写字母排序
			        tu = (x, d[x])
			        s.append(tu)
			    return s

			print(f(L))

		安分数来排

			L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

			d = {}

			for x,y in L:    #也是换成字典不过key字是分数
			    d[y] = x

			def f(n):
			    t = []
			    s = []
			    for i in n:
			        t.append(i[1])
			    for x in sorted(t, key=abs):
			        tu = (d[x],x)
			        s.append(tu)
			    return s

			print(f(L))

        
        
    返回函数
    	把函数作为结果值返回。

		我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：

		def calc_sum(*args):
		    ax = 0
		    for n in args:
		        ax = ax + n
		    return ax
		但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：

		def lazy_sum(*args):
		    def sum():
		        ax = 0
		        for n in args:
		            ax = ax + n
		        return ax
		    return sum
		当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

		>>> f = lazy_sum(1, 3, 5, 7, 9)
		>>> f
		<function lazy_sum.<locals>.sum at 0x101c6ed90>
		调用函数f时，才真正计算求和的结果：

		>>> f()
		25
		在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

		返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量

		def count():
		    fs = []
		    for i in range(1, 4):
		        def f():
		             return i*i
		        fs.append(f)
		    return fs

		f1, f2, f3 = count()
		在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。

		你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：

		>>> f1()
		9
		>>> f2()
		9
		>>> f3()
		9
		全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

		如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

		def count():
		    def f(j):
		        def g():
		            return j*j
		        return g
		    fs = []
		    for i in range(1, 4):
		        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
		    return fs

		练习利用闭包返回一个计数器函数，每次调用它返回递增整数

			def count():
			    n = 0
			    def f():
			        nonlocal n   #声明变成了全局变量,每次调用都是count里的n值
			        n = n + 1
			        return n
			    return f

			now_a = count()

			print(now_a(), now_a(), now_a())


	匿名函数
		当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
		>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
		[1, 4, 9, 16, 25, 36, 49, 64, 81]
		通过对比可以看出，匿名函数lambda x: x * x实际上就是：

		def f(x):
		    return x * x

		关键字lambda表示匿名函数，冒号前面的x表示函数参数。

		匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

		用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

		>>> f = lambda x: x * x
		>>> f
		<function <lambda> at 0x101c6ef28>
		>>> f(5)
		25


		同样，也可以把匿名函数作为返回值返回，比如：

		def build(x, y):
	    	return lambda: x * x + y * y   #注意函数没有参数


	装饰器
		由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。

			>>> def now():
			...     print('2015-3-25')
			...
			>>> f = now
			>>> f()
			2015-3-25
			函数对象有一个__name__属性，可以拿到函数的名字：

			>>> now.__name__
			'now'
			>>> f.__name__
			'now'

		假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

		本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

			def log(func):
			    def wrapper(*args, **kw):  #可接受任意参数调用,但此例无参数
			        print('call %s():' % func.__name__)
			        return func(*args, **kw)
			    return wrapper
		观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

			@log
			def now():
			    print('2015-3-25')
			调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：

			>>> now()
			call now():
			2015-3-25
			把@log放到now()函数的定义处，相当于执行了语句：

			now = log(now)


			还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：

			>>> now.__name__
			'wrapper'
			因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。

		所以完整的代码为
			import functools

			def log(func):
			    @functools.wraps(func)
			    def wrapper(*args, **kw):
			        print('call %s():' % func.__name__)
			        return func(*args, **kw)
			    return wrapper

			@log
			def now():
			    print('2015-3-25')

			now()


		带参数的装饰器
			import functools

			def log(text):
			    def decorator(func):
			        @functools.wraps(func)
			        def wrapper(*args, **kw):
			            print('%s %s():' % (text, func.__name__))
			            return func(*args, **kw)
			        return wrapper
			    return decorator

			@log('execute')
			def now():
			    print('2015-3-25')

			#效果相当于  now = log('execute')(now)，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。


		练习 请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间(自己写的)

			import time

			def count_time(func):
			    def wrap():
			        start = time.time() #时间截(当前秒数)
			        func()             #函数在开始与结束间执行
			        end = time.time()
			        usetime = end - start
			        print('脚本运行所需时间 %.2f' % usetime)
			        
			    return wrap

			@count_time
			def ooo():
			    print('hello')
			    time.sleep(3)   #测试等待3s
			    print('yes')

			ooo()