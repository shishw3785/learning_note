python简介
	连google都在大规模使用,不用担心学了没用
	当用一种语言开始软件开发时,除了编写代码外,还需要很多基本已经这好的东西加速开发,如开发一个邮件客户端,如果从最底层开始编写网络协议相关的代码可能要一年多也不行.高级语言通常会提供一个比较完善的基础代码库,可以直接调用.如由件协议的SMTP库,我们就可以在现有代码库上开发,短时间就能写邮件客户端软件出来

	python提供了非常完善的基础代码库,包括网络,文件,GUI,数据库等和第三方库,可以直接使用

	优点
		简洁,高效
	缺点
		运行速度慢,因为是解释型语言,代码在执行时会一行一行地翻译成CPU能理解的机器码

python解释器
	当编写python代码时,得到的是一个.py扩展名的文本文件,要运行代码,就需要python解释器去执行

	官网安装Python后就得到了一个官方解释器材cpython(使用最广),用c语言开发,在命令行下python就启动cpython了

输入和输出
	>>> print('hello, world')
	hello, world

	>>> print('hello', 'world')
	hello world    #print接受多个字符,用逗号隔开,打印时每遇一个, 就会输出一个空格

	print()也可以打印整数，或者计算结果：

	>>> print(300)
	300
	>>> print(100 + 200)
	300

	>>> print('100 + 200 =', 100 + 200)
	100 + 200 = 300

	输入
	>>> name = input()
	Michael
	>>> name
	'Michael'

	>>> name = input('please enter your name: ') #显示字符串提醒
	please enter your name: leison
	>>> print('hello', name)
	hello leison

python基础
	任何一种语言都有一套语法,编译器或解释器就是把符合语法的代码转译给CPU能识别的机器码

	# 开头是注释
	每一行都是一个语句,语句以冒号 : 结尾时,缩进的语句称为代码块,应以4个空格缩进,好处是让长语句缩短成短语句,缺点是复制后的代码要重新检验缩进标准

	数据类型,Python能直接处理的数据类型
		整数
			可以处理任意大意的整数,包括负整数
				1 100 -8 0
			十六进制
				十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。

		浮点数
			1.23，3.14，-9.01
			很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等

			整数和浮点数在计算机内部存储方式不同,整数是精确的,而浮点数有时要四舍五入

		字符串
			以'' 或 "" 括起来的任意文本
				'abc'
				"Im' ok" # 单引号本身也是字符,用双引号括起来,里面的空格也是字符

			转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：

			>>> print('I\'m ok.')
			I'm ok.
			>>> print('I\'m learning\nPython.')
			I'm learning
			Python.
			>>> print('\\\n\\')
			\
			\
			如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：

			>>> print('\\\t\\')
			\       \
			>>> print(r'\\\t\\')
			\\\t\\

			如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：

			>>> print('''line1
			... line2
			... line3''')
			line1
			line2
			line3

		布尔值
			只有True和False,要么是True要么是False

			>>> True
			True
			>>> False
			False
			>>> 3 > 2
			True
			>>> 3 > 5
			False

			布尔值可以用and、or和not运算。

			and运算是与运算，只有所有都为True，and运算结果才是True：

			>>> True and True
			True
			>>> True and False
			False
			>>> False and False
			False
			>>> 5 > 3 and 3 > 1
			True
			or运算是或运算，只要其中有一个为True，or运算结果就是True：

			>>> True or True
			True
			>>> True or False
			True
			>>> False or False
			False
			>>> 5 > 3 or 1 > 3
			True

			not运算是非运算，它是一个单目运算符，把True变成False，False变成True：

			>>> not True
			False
			>>> not False
			True
			>>> not 1 > 2
			True

		空值
			特殊值,用None表示,不能理解为0,因为0有意义

		变量
			等号 = 是赋值语句,可以把任意数据类型赋值给变量
			变量名必须是英文数字与_的组合,不能是数字开头

			a = 1
			变量a是一个整数。

			原理,在内容中创建数据1,在内存中创建变量且名a并把它指向数据1

			t_007 = 'T007'
			变量t_007是一个字符串。

			Answer = True
			变量Answer是一个布尔值True。

		python是动态语言
			a = 1
			a = 'abc'
			变量可以赋值任何类型(不固定),所以是动态固语言,灵活,JAVA是静态语言变量要先定义数据类型如int a = 1

		赋值 = 
			x = 10
			x = x + 2  --> x =12
			=不是数学常识的=号,而是赋值的意思

		常量
			通常用大写表示
			如 PI = 3.1415926

		/ 除法
			/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

			>>> 9 / 3
			3.0
			还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

			>>> 10 // 3
			3
		 % 求余
		 	>>> 10 % 3
			1

字符串和编码
	
	编码
	Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
	Unicode编码转化为“可变长编码”的UTF-8编码

	在内存中,统一用Unicode编码,当需要保存到硬盘或传输时(浏览器转输内容)就换UTF-8编码

	python字符串
		在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：

		>>> print('包含中文的str')
		包含中文的str
		对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

		>>> ord('A')
		65
		>>> ord('中')
		20013
		>>> chr(66)
		'B'
		>>> chr(25991)
		'文'

		如果知道字符的整数编码，还可以用十六进制这么写str：

		>>> '\u4e2d\u6587'
		'中文'

		由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

		Python对bytes类型的数据用带b前缀的单引号或双引号表示：

		x = b'ABC'
		要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。(节省了空间)

		以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

		>>> 'ABC'.encode('ascii')
		b'ABC'
		>>> '中文'.encode('utf-8')
		b'\xe4\xb8\xad\xe6\x96\x87'
		>>> '中文'.encode('ascii')
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
		纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

		反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

		>>> b'ABC'.decode('ascii')
		'ABC'
		>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
		'中文'
		如果bytes中包含无法解码的字节，decode()方法会报错：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
		Traceback (most recent call last):
		  ...
		UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
		如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

		>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
		'中'

		要计算str包含多少个字符，可以用len()函数：

		>>> len('ABC')
		3
		>>> len('中文')
		2
		len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

		>>> len(b'ABC')
		3
		>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
		6
		>>> len('中文'.encode('utf-8'))  #encode转成bytes类型
		6
		可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

		python保存的文本如果包含中文要在文件头添加
		#!/usr/bin/env python3  #linux 设置
		# -*- coding: utf-8 -*-   #编码设置
		并且文本编译软件设置选择UTF-8 without BOM编码



		格式化输出
		>>> 'Hello, %s' % 'world'
		'Hello, world'
		>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
		'Hi, Michael, you have $1000000.'
		你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

		补位
		>>> print('%2d-%02d' % (3,1))
		3-01
		>>> print('%.2f' % 3.1415)
		3.14

		需要 %字符,可以通过%转义
		>>> 'growth rate: %d %%' % 7
		'growth rate: 7 %'

		format()也可以格式化输出


list和tuple 
	列表是同置的一种内置的数据类型,有序的集合,可以随时添加和删除其中的元素

	>>> classmates = ['Michael', 'Bob', 'Tracy']
	>>> classmates
	['Michael', 'Bob', 'Tracy']

	可以用len()函数计算里面的个数
	>>> len(classmates)
	3

	用索引来访问里面元素,从0开始
	>>> classmates[0]
	'Michael'
	>>> classmates[1]
	'Bob'
	>>> classmates[2]
	'Tracy'
	>>> classmates[3]
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	IndexError: list index out of range

	取最后一个元素
	classmates[-1]
	>>>'Tracy'
	以此类推可以获取倒数的元素-2,-3

	List是可变的元素,可以追加素到末尾
	classmates.append('Adm')
	>>> classmates
	['Michael', 'Bob', 'Tracy', 'Adam']

	也可以把元素插入指定位置,比如索引1的位置
	classmates.insert(1,'Jack')
	['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']

	删除List末尾元素
	classmates.pop()
	'Adam'
	>>> classmates
	['Michael', 'Jack', 'Bob', 'Tracy']

	删除指定位置元素,pop(i)
	classmates.pop(1)
	['Michael', 'Bob', 'Tracy']

	元素替换
	classmates[1] = 'Sarah'
	['Michael', 'Sarah', 'Tracy']

	list元素的数据类型也可以不同
	L = ['Apple', 123, True ]

	list元素也可以是另一个List
	s = ['python', 'java', ['asp', 'php'], 'sql']

	p = ['asp', 'php']
	s = ['python', 'java', p, 'sql']  #元素也可以是变量

	len(s)
	4

	s[2][1] 或p[1]
	>>> 'php'

	空list
	L = []
	len(L)
	>>> 0 

	tuple元组
		有序不可变,一旦初始化就不能修改

		classmates = ('Michael', 'Bob', 'Tracy')
		可以通过 classmates[i] 索引读取数据

		但是不能变了,没有append(),insert(),也不能重新赋值classmates[1] = 'hello'

		空的tuple，可以写成()：

			>>> t = ()
			>>> t
			()

		"可变的元组"
		>>> t = ('a', 'b', ['A', 'B'])
		>>> t[2][0] = 'X'
		>>> t[2][1] = 'Y'
		>>> t
		('a', 'b', ['X', 'Y'])
		#不可变指的是元素的指向不可变,但元素本身是List它是可变的

条件判断
	if语句

		if <条件判断1>:
		    <执行1>
		elif <条件判断2>:
		    <执行2>
		elif <条件判断3>:
		    <执行3>
		else:
		    <执行4>

	例
	age = 16
	if age > 18:
	    print('adult', 'you age is', age)
	elif age < 18:
	    print('baby', 'you age is', age)
	else:
	    print('i dont know')

	 简写
	 	if x:
		    print('True')
		只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。

	结合input()
		s = input('birth: ')
		birth = int(s)   #利用int()把str转成整数类型
		if birth < 2000:
		    print('00前')
		else:
		    print('00后')


循环
	for循环

	for x in ...循环就是把每个元素(可以是列表或元组的元素)代入变量x，然后执行缩进块的语句。

		例
		sum = 0
		for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
		    sum = sum + x
		print(sum)

		range()函数可以生成整数序列,利用list()函数可以让其转成列表
		>>> list(range(5))    #从0开始小于5的整数
		[0, 1, 2, 3, 4]


	while循环
		while循环，只要条件满足，就不断循环，条件不满足时退出循环

		例
		sum = 0
		n = 99
		while n > 0:
		    sum = sum + n
		    n = n - 2
		print(sum)

	break语句
		提前结束循环

		n = 1
		while n <= 100:
		    if n > 10: # 当n = 11时，条件满足，执行break语句
		        break # break语句会结束当前循环
		    print(n)
		    n = n + 1
		print('END')

	continue
		通过continue语句，跳过当前的这次循环，直接开始下一次循环。

		n = 0
		while n < 10:
		    n = n + 1
		    if n % 2 == 0: # 如果n是偶数，执行continue语句
		        continue   #语句会直接继续下一轮循环，后续的print()语句不会执行
		    print(n)


字典dic 与 set

	字典
		>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}  #创建字典
		>>> d['Michael']
		95

		#key-value存储方式 查询速度快

		把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

		>>> d['Adam'] = 67   #额外添加键值
		>>> d['Adam']
		67
		由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

		>>> d['Jack'] = 90     
		>>> d['Jack']
		90
		>>> d['Jack'] = 88    #修改值
		>>> d['Jack']
		88

		要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：

		>>> 'Thomas' in d
		False
		二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：

		>>> d.get('Thomas')
		>>> d.get('Thomas', -1)
		-1
		注意：返回None的时候Python的交互环境不显示结果。

		要删除一个key，用pop(key)方法，对应的value也会从dict中删除：

		>>> d.pop('Bob')
		75
		>>> d
		{'Michael': 95, 'Tracy': 85}

		请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

		和list比较，dict有以下几个特点：

		查找和插入的速度极快，不会随着key的增加而变慢；
		需要占用大量的内存，内存浪费多。
		而list相反：

		查找和插入的时间随着元素的增加而增加；
		占用空间小，浪费内存很少。
		所以，dict是用空间来换取时间的一种方法

		dic 的key必须是不可变的对象,通过key计算出velue称做哈希算法
			字符串与整数是不可变的,可以做为key值
			list是可变的,不能做key值

	set
		set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

		要创建一个set，需要提供一个list作为输入集合：

		>>> s = set([1, 2, 3])
		>>> s
		{1, 2, 3}
		注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

		重复元素在set中自动被过滤：

		>>> s = set([1, 1, 2, 2, 3, 3])
		>>> s
		{1, 2, 3}
		通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		>>> s.add(4)
		>>> s
		{1, 2, 3, 4}
		通过remove(key)方法可以删除元素：

		>>> s.remove(4)
		>>> s
		{1, 2, 3}
		set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

		>>> s1 = set([1, 2, 3])
		>>> s2 = set([2, 3, 4])
		>>> s1 & s2
		{2, 3}
		>>> s1 | s2
		{1, 2, 3, 4}
		set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象

		对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：

		>>> a = ['c', 'b', 'a']
		>>> a.sort()
		>>> a
		['a', 'b', 'c']
		而对于不可变对象，比如str，对str进行操作呢：

		>>> a = 'abc'
		>>> a.replace('a', 'A')
		'Abc'
		>>> a
		'abc'             #虽然有replace方法,但a的变量内容还是不变的


函数
	调用函数
		调用abs函数：

		求绝对值
		>>> abs(100)
		100
		>>> abs(-20)
		20

		max函数max()可以接收任意多个参数，并返回最大的那个：

		>>> max(1, 2)
		2
		>>> max(2, 3, 1, -5)
		3

		数据类型转换
		>>> int('123')
		123
		>>> int(12.34)
		12
		>>> float('12.34')
		12.34
		>>> str(1.23)
		'1.23'
		>>> str(100)
		'100'
		>>> bool(1)
		True
		>>> bool('')   #整数0也是False
		False

		函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

		>>> a = abs # 变量a指向abs函数
		>>> a(-1) # 所以也可以通过a调用abs函数
		1

		调用函数要传入正确的参数,否则会出错,可以看错误信息


	定义函数
		def my_abs(x):
		    if x >= 0:
		        return x
		    else:
		        return -x

		print(my_abs(-99))

		用def语句, 函数名my_abs, x参数 , : 冒号  缩进语中编写函数体, 用 return 返回函数值

		一旦遇到return 时,函数就执行完毕,并将结果返回, 如果没有return语句,函数执行完毕也会返回结果,只是结果为 None,  return None 可以简写为 return

		把my_abs()函数定义保存为abstest.py文件,那么可以在该文件的当前目录下启动python解释器, 用  from abstest import my_abs 来导入my_abs()函数,注意是 abstest不包含  .py

		空函数
			定义一个函数什么事也不想做

			def nop():
				pass

			pass语句什么都不做,作用,作为占位符,如还没想好怎么写代码,可以放pass,让代码先能运行起来, pass 也可以放在其他语句中

			if age >= 18:
				pass	

			修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：

				def my_abs(x):
				    if not isinstance(x, (int, float)):
				        raise TypeError('bad operand type')
				    if x >= 0:
				        return x
				    else:
				        return -x

		返回多个值
			import math

			def move(x, y, step, angle=0):
			    nx = x + step * math.cos(angle)
			    ny = y - step * math.sin(angle)
			    return nx, ny

			>>> x, y = move(100, 100, 60, math.pi / 6)
			>>> print(x, y)
			151.96152422706632 70.0
			但其实这只是一种假象，Python函数返回的仍然是单一值：

			>>> r = move(100, 100, 60, math.pi / 6)
			>>> print(r)
			(151.96152422706632, 70.0)
			其实返回的是一个元组


	函数的参数
		计算x4、x5…

		def power(x, n):
		    s = 1
		    while n > 0:
		        n = n - 1
		        s = s * x
		    return s

		默认参数
			def power(x, n=2):
			    s = 1
			    while n > 0:
			        n = n - 1
			        s = s * x
			    return s
			这样，当我们调用power(5)时，相当于调用power(5, 2)：

			>>> power(5)
			25
			>>> power(5, 2)
			25

			注意：

				一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

				二是如何设置默认参数。

				当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

				使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

			def enroll(name, gender, age=6, city='Beijing'):
			    print('name:', name)
			    print('gender:', gender)
			    print('age:', age)
			    print('city:', city)
			这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：

			>>> enroll('Sarah', 'F')
			name: Sarah
			gender: F
			age: 6
			city: Beijing

			只有与默认参数不符的学生才需要提供额外的信息：

			enroll('Bob', 'M', 7) # city没有取值,使用默认值
			enroll('Adam', 'M', city='Tianjin')  #不按顺序设值要指名参数名city

			定义默认参数要牢记一点：默认参数必须指向不变对象！

			def add_end(L=None):                   #在如果 L = [],每次add_end()后L都会添加END
			    if L is None:
			        L = []
			    L.append('END')
			    return L
			现在，无论调用多少次，都不会有问题：

			>>> add_end()
			['END']
			>>> add_end()
			['END']

