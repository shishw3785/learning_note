install nginx
	yum install
		create /etc/yum.repos.d/nginx.repo  #and write contents from nginx Centos

	
		yum install nginx # and verify GPG key

	Building nginx from Sources
		user configure command and parameters
			--help
			--prefix=path
			.......

		Example of parameters usage (all of this needs to be typed in one line):

			./configure
			    --sbin-path=/usr/local/nginx/nginx
			    --conf-path=/usr/local/nginx/nginx.conf
			    --pid-path=/usr/local/nginx/nginx.pid
			    --with-http_ssl_module
			    --with-pcre=../pcre-8.44
			    --with-zlib=../zlib-1.2.11
			After configuration, nginx is compiled and installed using make.

Beginner' s Guide
	nginx has one master process and several worker processes. The main purpose of the master process is to read and evaluate configuration, and maintain(维护) worker processes. Worker processes do actual processing of requests. nginx employs event-based model and OS-dependent mechanisms(事件驱动模型) to efficiently distribute(分发) requests among worker processes.


	start, stop and reload configureation
		To start nginx, run the executable file. Once nginx is started, it can be controlled by invoking the executable with the -s parameter. Use the following syntax:

		nginx -s signal
		Where signal may be one of the following:

		stop — fast shutdown
		quit — graceful shutdown
		reload — reloading the configuration file
		reopen — reopening the log files
		For example, to stop nginx processes with waiting for the worker processes to finish serving current requests, the following command can be executed:

		nginx -s quit

		Changes made in the configuration file will not be applied until the command to reload configuration is sent to nginx or it is restarted. To reload configuration, execute:

			nginx -s reload

			Once the master process receives the signal to reload configuration, it checks the syntax validity of the new configuration file and tries to apply the configuration provided in it. If this is a success, the master process starts new worker processes and sends messages to old worker processes, requesting them to shut down. Otherwise, the master process rolls back the changes and continues to work with the old configuration. Old worker processes, receiving a command to shut down, stop accepting new connections and continue to service current requests until all such requests are serviced. After that, the old worker processes exit.

		A signal may also be sent to nginx processes with the help of Unix tools such as the kill utility. In this case a signal is sent directly to a process with a given process ID. The process ID of the nginx master process is written, by default, to the nginx.pid in the directory /usr/local/nginx/logs or /var/run. For example, if the master process ID is 1628, to send the QUIT signal resulting in nginx’s graceful shutdown, execute:

			kill -s QUIT 1628



	Configuration file's structure
		If a block directive can have other directives inside braces, it is called a context (examples: events, http, server, and location).

		Directives placed in the configuration file outside of any contexts are considered to be in the main context. The events and http directives reside(属于) in the main context, server in http, and location in server.

	serving static content

		http {
		    server {
		    	location / {
			        root /data/www;
			    }

			    location /images/ {
			        root /data;
			    }
		    }
		}

		 For example, in response to the http://localhost/images/example.png request nginx will send the /data/images/example.png file. If such file does not exist, nginx will send a response indicating the 404 error. Requests with URIs not starting with /images/ will be mapped onto the /data/www directory. For example, in response to the http://localhost/some/example.html request nginx will send the /data/www/some/example.html file.

	Setting up a simple proxy server
		One of the frequent uses of nginx is setting it up as a proxy server, which means a server that receives requests, passes them to the proxied servers, retrieves responses from them, and sends them to the clients.

		In this example, both servers will be defined on a single nginx instance.

		First, define the proxied server by adding one more server block to the nginx’s configuration file with the following contents:

		server {
		    listen 8080;
		    root /data/up1;

		    location / {
		    }
		}

		proxy server configuration

			server {
			    location / {
			        proxy_pass http://localhost:8080/;
			    }

			    location ~ \.(gif|jpg|png)$ {
			        root /data/images;
			    }
			}

		This server will filter requests ending with .gif, .jpg, or .png and map them to the /data/images directory (by adding URI to the root directive’s parameter) and pass all other requests to the proxied server configured above.


	setting up fastcgi proxying
		nginx can be used to route requests to FastCGI servers which run applications built with various frameworks and programming languages such as PHP.

		Suppose the FastCGI server is accessible on localhost:9000.

		server {
		    location / {
		        fastcgi_pass  localhost:9000;
		        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
		        fastcgi_param QUERY_STRING    $query_string;
		    }

		    location ~ \.(gif|jpg|png)$ {
		        root /data/images;
		    }
		}
		This will set up a server that will route all requests except for(除了) requests for static images to the proxied server operating on localhost:9000 through the FastCGI protocol.



nginx upgdate
	https://www.cnblogs.com/linuxk/p/9963916.html  # see help
	先查看旧的的编译参数
		nginx -v
	在新的nginx版本中编译并添加进去然后 make
	备份原来的nginx启动文件
		cd /usr/local/nginx/sbin
		mv nginx nginx_old
	cp新nginx的obj目录下的nginx到/usr/local/nginx/sbin/
	回到新的nginx目录下更新make upgrade

		[root@localhost nginx-1.14.1]# make upgrade  #这一步会将结束旧进程，并开启新的进程进行管理nginx的任务，从而达到平滑升级的效果
		/usr/local/nginx/sbin/nginx -t
		nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
		nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
		kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`  #收到USER2信呈后,会将旧的ningx.pid改名nginx.pid.oldbin
		sleep 1
		test -f /usr/local/nginx/logs/nginx.pid.oldbin
		kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`

		这里需要注意的是，使用make upgrade进行平滑升级时，会默认发送USR2信号到/usr/local/nginx/logs/nginx.pid，但是如果你的pid文件位置不一致，就会出现文件不存在的ERROR
		而我们需要做的是，放弃使用make upgrade，而是直接使用以下命令，假设nginx.pid的路径为：/var/run/nginx.pid
		[root@localhost nginx-1.14.1]# /usr/local/nginx/sbin/nginx -t
		nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
		nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
		[root@localhost nginx-1.14.1]# kill -USR2 `cat /var/run/nginx.pid`
		此时会在/var/run/下生成一个nginx.pid.oldbin的pid文件
		[root@localhost nginx-1.14.1]# kill -QUIT `cat /var/run/nginx.pid.oldbin`  #退出旧进程


nginx.conf 文件结构
	全局块
	event 块
	http 块
		包含多个server块
			包含多个location块

	同一配置块中嵌套的配置块不存在次序的关系
	某个指令在两个不同层级中,则采用'就近原则',以较低层级中的配置为准

	全局块
		全局块是默认配置文件从开始到event块之间的一部分内容,主要设置一些影响nginx整体运行的配置指令,如运行nginx的用户(组),欢允许生成的work process数,nginx pid等
	event块
		涉及的指令主要影响服务器与用户的网络连接. 常用的设置包括对多work process下的网络连接进行序列化,选取哪种事件驱动模型处理连接请求,每个work process可以同时支持的最大连接数等
	http块
		重要部分,代理,缓存,日志定义等绝大多数功能和第三方模块的配置都是放在这里
		http块可以包含自己的全局块,也可以包含server块,server块中又可以包含 location块
		可以在http配置指令包括文件引入,MIME-TYPE定义,日志定义,是否使用sendfile传输文件,连接超时时间,单连接请求数上限等
	server块
		http块可以包含多个server块,server块相当于一台虚拟主机,常见的配置项是本虚拟主机的监听配置和名称或IP配置
	location块
		每个server可以包含多个location块,主要作用是基于nginx服务器收到的请求字符串,对除虚拟主机名称之外的字符串进行匹配,对特定的请求进行处理


	user user [group];
		指定Nginx运行的用户,group为可选项,如果希望所有用户都能执行Nginx,可设置为用户与组nobody,或直接#掉这行
	worker_process number | auto;
		配置允许生成的worker_process数量,理论上是越大支持的并发数量越多,但worker_process数值受软件本身与操作系统与硬件等资源的制约
	include file;
		配置文件引入,可放入任何位置,支持相对路径
	accept_mutex on|off;
		设置网络连接的序列化.(UNIX网络编程)提到的惊群问题,当有一个连接来时,多个睡眠的进程被同时唤醒,但只有一个进程可获得连接,每次唤醒的进程越多,会影响系统性能,在nginx多进程下就有可能会有惊群.默认开启On,让连接序列化.此指令在event中配置
	multi_accept on|off;
		设置欢笑许时是接收多个网络,默认为off,即每个worker process一次只能接收一个新到达的连接
	use method
		可选有select,poll,epoll等模型,在event中配置
	worker_connections numbers;
		设置允许每一个worker process同时开启的最大连接数,默认1024,在event块内配置
	定义MIME-Type
		include       mime.types;
    	default_type  application/octet-stream;
    	在常用的浏览器中,可以显示的内容有HTML,XML,GIF,FLASH等媒体资源,浏览器需要区分这些资源,使用MIME TYPE,也主浊说MIME TYPE是网络资源的媒体

    自定义服务日志
    	access_log path [format [buffer=size]];
    		path 日志的文件存放路径
    		format 
    		size 配置临时存放日志的内存缓存区大小

    		access_log logs/access.log main;
    			main为log_format指令默定义的日志格式字符串的名称
    			此指令可在http块,server块和location块

    	log_format name string....;
    		name 格式字符串的名字,默认main
    		string 日志格式字符串,在定义的过程中,可以使用Nginx配置预设的一些变量获取内容,变量的名称使用双引号括起来,string整体使用单引号括起来

    		#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
		    #                  '$status $body_bytes_sent "$http_referer" '
		    #                  '"$http_user_agent" "$http_x_forwarded_for"';

		    此指令块只能在http配置

	sendfile on | of;
		开启sendfile()传输文件,开启后nginx性能提升,可在http,server location块中configure

	sendfile_max_chunk size;
		size如大于0,则每个worker_process每次调用sendfile()传输的数据量最大不能超过这个值,如设为0,则无限制,可在http server location中configure

	配置连接超时时间
		keepalive_timeout timeout [header_timeout];
			timeout 服务器端对连接的保持时间,默认75s
			header_timeout 可选项,在应答报文头部的Keep-Alive域设置超时时间

			如 keepalive_timeout 120s 100s
				在服务端保持连接120s,发给用户端的应答报文头部中Keep_Alive域的超时时间为100s

			可以上http,server,location块设置

	keepalive_requests numbers;
		服务器与客户端建立链接后,客户端通过此链接发送请求,这个指令用来限制请求数,默认设置100

	配置网络监听
		listen 192.168.1.10:8000 监听具体的IP和具体的端口上的连接
		listen 192.168.1.10 监听具体IP的所有端口连接
		listen 8000 监听具体port的所有IP连接,等于listen *:8000
		listen 192.168.1.10 default_server backlog=1024
			设置192.168.1.10的连接请求默认由此虚拟机处理,且允许最多1024网络连接同时处于挂起状态(因机器资源不足,暂时被淘汰调离出内存)

	基于名称的虚拟主机配置
		server_name name...;
			如server_name myserver.com www.myserver.com;
				第一个名称作为此虚拟主机的主要名称

		name中可以使用通配符*,但通配符只能用在三段字符组成的名称的首段或尾段,或两段
			server_name *.myserver.com www.myserver.*;

		name还可以使用正则表达式,并使用"~"作为正则表达式字符串的开始标记
			server_name ~^www\d+\.myserver\.com$;
				以www开头,^匹配行首, www后接1个或多个[0-9]的数字,\d代表0到9的任意一个数字, + 代表一个或多个前字符, . 在正则表达中有特殊含义,所以有用\转义, 后面是$匹配m行尾

			正则表则式捕获功能
				server_name ~^www\.(.+)\.com$;
					如www.myserver.com匹配成功,“myserver”字串就会被获取保存并记录到$1变量中,然后在server块的配置中,可以直接使用$1变量,同理也可以有$2,$3

		因server_name支持通配符又支持正则,如果都匹配成功,则顺序
			准确匹配server_name
			通配符在开始匹配server_name成功
			通配符在结尾匹配server_name成功
			正则表达式匹配成功

	基于IP的虚拟主机配置
		server
			{
				listen 80;
				server_name 192.168.1.31;
				.....
			}

		server
			{
				listen 80;
				server_name 192.168.1.32
				.....
			}
			这样来自192.168.1.31的请求就由第一台虚拟机来处理,第二台同理,个人理解就是只用IP来访问

	location [ = | ~ | ~* | ^~ ] uri [ ... ];
		= 用于标准url,要求请求字符串与uri严格匹配,如果匹配成功,就停止继续向下搜索并立即处理此请求
		~ 用于url包含正则表达式,区分大小写
		~* 用于url包含正则表达式,不区分大小写
		^~ 用于标准url,要求NGINX找到标枳url和请求字符串匹配度最高的location后,立即使用此location处理请求,而不再使用location块中的正则uri和请求符串做匹配
			浏览器传送URL时对一部分字符进行URL编码,比如空格被编码为 %20 , 问号被编译为 %3f 等, ^~ 有一个特点,它对uri中的这些符号会进行编码处理,如 location收到 /html/%20/data ,则当NGINX搜索到配置为 ^~ /html/ /data的location时可以匹配成功

	配置请求的根NGINX变量
		root path;
		path为NGINX收到请求后查找资源的根目录路径,PATH中可以包含NGINX变量
		可在http server location中配置,一般多locationf块,所以在Location配置多

		location /data/{
			root /locationtest1;
		}
		当收到/data/index.html请求时,将会到/locationtest1/data目录下找到index.html响应请求
		}

	更改location的URL alias
		alias path;

		如 location ~ ^/data/(.+\.(htm|html))$;
			{
				alias /locationtest1/other/$1;
			}

			当location收到/data/index.html的请求时,匹配成功,之后根据alias指令的配置,nginx将到/locationtest1/other目录下找index.html并响应请求

	设置网站的默认首页
		index file...;

		作用
			1 用户在发送请求访问网站时,请求地址可以不写首页名称
			2 可以根据请求内容设置不同的首页
		file 可以是多个文件名,用空格隔开,也可以是变量,变量默认为Index.html

		如 location ~ ^/data/(.+)/web/$
			{
				index index.$1.html index.my1.html index.html;
			}
			当收到/data/locationtest/web/时,匹配成功,$1为locationtest,然后到/data/locationtest/web目录下按照index顺序依次查找,index.locationtest.html index.my1.html index.html,首先找到哪个页面,就使用哪个页面响应请求